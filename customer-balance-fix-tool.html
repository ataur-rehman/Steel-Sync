<!DOCTYPE html>
<html>

<head>
    <title>Customer Balance Fix Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
        }

        .success {
            color: green;
        }

        .error {
            color: red;
        }

        .warning {
            color: orange;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 10px;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
        }

        .log {
            background: #f9f9f9;
            padding: 10px;
            font-family: monospace;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>
    <h1>üîß Customer Balance Fix Tool</h1>

    <div class="section">
        <h2>Step 1: Remove Balance Sync Entries</h2>
        <button onclick="cleanBalanceSyncEntries()">üßπ Clean Balance Sync Entries</button>
        <div id="cleanResults"></div>
    </div>

    <div class="section">
        <h2>Step 2: Recalculate All Customer Balances</h2>
        <button onclick="recalculateAllBalances()">üîÑ Recalculate All Balances</button>
        <div id="recalcResults"></div>
    </div>

    <div class="section">
        <h2>Step 3: Fix Running Balance in Ledger Entries</h2>
        <button onclick="fixRunningBalances()">‚ö° Fix Running Balances</button>
        <div id="fixResults"></div>
    </div>

    <div class="section">
        <h2>Diagnostics</h2>
        <button onclick="checkBalanceConsistency()">üîç Check Balance Consistency</button>
        <button onclick="showSampleLedger()">üìã Show Sample Ledger</button>
        <div id="diagnostics"></div>
    </div>

    <script type="module">
        let db;

        async function initializeDB() {
            try {
                const module = await import('./src/services/database.ts');
                db = new module.DatabaseService();
                await db.initialize();
                console.log('‚úÖ Database initialized');
            } catch (error) {
                console.error('‚ùå Failed to initialize database:', error);
                throw error;
            }
        }

        window.cleanBalanceSyncEntries = async function () {
            const results = document.getElementById('cleanResults');
            results.innerHTML = '<h3>üßπ Cleaning Balance Sync Entries</h3>';

            try {
                // Check for balance sync entries
                const syncEntries = await db.executeRawQuery(`
                    SELECT COUNT(*) as count FROM customer_ledger_entries 
                    WHERE description LIKE '%Balance synchronization%' 
                       OR description LIKE '%balance sync%'
                       OR description LIKE '%ledger sync%'
                       OR transaction_type = 'balance_sync'
                `);

                const count = syncEntries[0].count;
                results.innerHTML += `<p>Found ${count} balance synchronization entries</p>`;

                if (count > 0) {
                    // Delete them
                    await db.executeRawQuery(`
                        DELETE FROM customer_ledger_entries 
                        WHERE description LIKE '%Balance synchronization%' 
                           OR description LIKE '%balance sync%'
                           OR description LIKE '%ledger sync%'
                           OR transaction_type = 'balance_sync'
                    `);

                    results.innerHTML += `<p class="success">‚úÖ Successfully deleted ${count} fake balance sync entries</p>`;
                } else {
                    results.innerHTML += `<p class="success">‚úÖ No balance sync entries found</p>`;
                }

            } catch (error) {
                results.innerHTML += `<p class="error">‚ùå Error: ${error.message}</p>`;
            }
        };

        window.recalculateAllBalances = async function () {
            const results = document.getElementById('recalcResults');
            results.innerHTML = '<h3>üîÑ Recalculating All Customer Balances</h3>';

            try {
                // Get all customers
                const customers = await db.executeRawQuery(`
                    SELECT id, name, balance FROM customers ORDER BY id
                `);

                results.innerHTML += `<p>Processing ${customers.length} customers...</p>`;

                let fixed = 0;
                let errors = 0;

                for (const customer of customers) {
                    try {
                        // Calculate correct balance from ledger
                        const balanceResult = await db.executeRawQuery(`
                            SELECT 
                                COALESCE(SUM(CASE WHEN entry_type = 'debit' THEN amount ELSE -amount END), 0) as correct_balance
                            FROM customer_ledger_entries 
                            WHERE customer_id = ?
                        `, [customer.id]);

                        const correctBalance = parseFloat(balanceResult[0].correct_balance || 0);
                        const currentBalance = parseFloat(customer.balance || 0);

                        if (Math.abs(correctBalance - currentBalance) > 0.01) {
                            // Update customer balance
                            await db.executeRawQuery(`
                                UPDATE customers 
                                SET balance = ?, updated_at = CURRENT_TIMESTAMP 
                                WHERE id = ?
                            `, [correctBalance, customer.id]);

                            results.innerHTML += `<p class="warning">Fixed ${customer.name}: ${currentBalance.toFixed(2)} ‚Üí ${correctBalance.toFixed(2)}</p>`;
                            fixed++;
                        }
                    } catch (customerError) {
                        results.innerHTML += `<p class="error">Error with ${customer.name}: ${customerError.message}</p>`;
                        errors++;
                    }
                }

                results.innerHTML += `<p class="success">‚úÖ Completed: ${fixed} balances fixed, ${errors} errors</p>`;

            } catch (error) {
                results.innerHTML += `<p class="error">‚ùå Error: ${error.message}</p>`;
            }
        };

        window.fixRunningBalances = async function () {
            const results = document.getElementById('fixResults');
            results.innerHTML = '<h3>‚ö° Fixing Running Balances in Ledger Entries</h3>';

            try {
                // Get all customers
                const customers = await db.executeRawQuery(`
                    SELECT id, name FROM customers ORDER BY id
                `);

                for (const customer of customers) {
                    results.innerHTML += `<p>Processing ${customer.name}...</p>`;

                    // Get all ledger entries for this customer in chronological order
                    const entries = await db.executeRawQuery(`
                        SELECT id, entry_type, amount, balance_before, balance_after
                        FROM customer_ledger_entries 
                        WHERE customer_id = ?
                        ORDER BY date ASC, created_at ASC
                    `, [customer.id]);

                    if (entries.length === 0) continue;

                    let runningBalance = 0;

                    for (let i = 0; i < entries.length; i++) {
                        const entry = entries[i];
                        const amount = parseFloat(entry.amount || 0);

                        // Calculate balance_before for this entry
                        const balanceBefore = runningBalance;

                        // Calculate balance_after
                        const balanceAfter = entry.entry_type === 'debit'
                            ? balanceBefore + amount
                            : balanceBefore - amount;

                        // Update the entry if values are wrong
                        if (Math.abs(entry.balance_before - balanceBefore) > 0.01 ||
                            Math.abs(entry.balance_after - balanceAfter) > 0.01) {

                            await db.executeRawQuery(`
                                UPDATE customer_ledger_entries 
                                SET balance_before = ?, balance_after = ?
                                WHERE id = ?
                            `, [balanceBefore, balanceAfter, entry.id]);
                        }

                        // Update running balance for next iteration
                        runningBalance = balanceAfter;
                    }
                }

                results.innerHTML += `<p class="success">‚úÖ Fixed running balances for all customers</p>`;

            } catch (error) {
                results.innerHTML += `<p class="error">‚ùå Error: ${error.message}</p>`;
            }
        };

        window.checkBalanceConsistency = async function () {
            const results = document.getElementById('diagnostics');
            results.innerHTML = '<h3>üîç Balance Consistency Check</h3>';

            try {
                // Check for inconsistencies
                const inconsistencies = await db.executeRawQuery(`
                    SELECT 
                        c.id, c.name, c.balance as stored_balance,
                        COALESCE(SUM(CASE WHEN l.entry_type = 'debit' THEN l.amount ELSE -l.amount END), 0) as calculated_balance,
                        ABS(c.balance - COALESCE(SUM(CASE WHEN l.entry_type = 'debit' THEN l.amount ELSE -l.amount END), 0)) as difference
                    FROM customers c
                    LEFT JOIN customer_ledger_entries l ON c.id = l.customer_id
                    GROUP BY c.id, c.name, c.balance
                    HAVING ABS(difference) > 0.01
                    ORDER BY difference DESC
                `);

                if (inconsistencies.length === 0) {
                    results.innerHTML += `<p class="success">‚úÖ All customer balances are consistent!</p>`;
                } else {
                    results.innerHTML += `<p class="warning">‚ö†Ô∏è Found ${inconsistencies.length} inconsistencies:</p>`;
                    results.innerHTML += '<table><tr><th>Customer</th><th>Stored</th><th>Calculated</th><th>Difference</th></tr>';
                    inconsistencies.forEach(inc => {
                        results.innerHTML += `<tr>
                            <td>${inc.name}</td>
                            <td>${parseFloat(inc.stored_balance).toFixed(2)}</td>
                            <td>${parseFloat(inc.calculated_balance).toFixed(2)}</td>
                            <td>${parseFloat(inc.difference).toFixed(2)}</td>
                        </tr>`;
                    });
                    results.innerHTML += '</table>';
                }

            } catch (error) {
                results.innerHTML += `<p class="error">‚ùå Error: ${error.message}</p>`;
            }
        };

        window.showSampleLedger = async function () {
            const results = document.getElementById('diagnostics');
            results.innerHTML += '<h3>üìã Sample Customer Ledger</h3>';

            try {
                // Get a customer with recent activity
                const sampleEntries = await db.executeRawQuery(`
                    SELECT 
                        customer_name, entry_type, amount, description, 
                        balance_before, balance_after, date, time
                    FROM customer_ledger_entries 
                    ORDER BY created_at DESC 
                    LIMIT 10
                `);

                if (sampleEntries.length > 0) {
                    results.innerHTML += '<table><tr><th>Customer</th><th>Type</th><th>Amount</th><th>Description</th><th>Before</th><th>After</th><th>Date</th></tr>';
                    sampleEntries.forEach(entry => {
                        results.innerHTML += `<tr>
                            <td>${entry.customer_name}</td>
                            <td>${entry.entry_type}</td>
                            <td>${parseFloat(entry.amount).toFixed(2)}</td>
                            <td>${entry.description}</td>
                            <td>${parseFloat(entry.balance_before || 0).toFixed(2)}</td>
                            <td>${parseFloat(entry.balance_after || 0).toFixed(2)}</td>
                            <td>${entry.date} ${entry.time}</td>
                        </tr>`;
                    });
                    results.innerHTML += '</table>';
                } else {
                    results.innerHTML += '<p>No ledger entries found</p>';
                }

            } catch (error) {
                results.innerHTML += `<p class="error">‚ùå Error: ${error.message}</p>`;
            }
        };

        // Initialize when page loads
        initializeDB().catch(error => {
            document.body.innerHTML = `<h1>‚ùå Failed to initialize database</h1><p>${error.message}</p>`;
        });
    </script>
</body>

</html>