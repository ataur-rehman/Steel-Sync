<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Column Fix Tool - Permanent Solution</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .fix-button {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
        }
        .fix-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .log-container {
            background: #1e1e1e;
            color: #00ff00;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            max-height: 500px;
            overflow-y: auto;
            margin-top: 20px;
        }
        .success {
            color: #28a745;
            font-weight: bold;
        }
        .error {
            color: #dc3545;
            font-weight: bold;
        }
        .warning {
            color: #ffc107;
            font-weight: bold;
        }
        .info {
            color: #17a2b8;
            font-weight: bold;
        }
        .status-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üõ†Ô∏è Comprehensive Database Column Fix Tool</h1>
        <h2>Permanent Solution for All Column Missing Errors</h2>
        
        <div class="status-card">
            <h3>üéØ What This Tool Fixes:</h3>
            <ul>
                <li>‚úÖ <strong>stock_receiving_items.expiry_date</strong> - Missing column error</li>
                <li>‚úÖ <strong>stock_receiving_items.notes</strong> - Missing column error</li>
                <li>‚úÖ <strong>vendor_payments.payment_channel_id</strong> - Missing column error</li>
                <li>‚úÖ <strong>vendor_payments.reference_number</strong> - Missing column error</li>
                <li>‚úÖ <strong>All future column missing errors</strong> - Permanent prevention</li>
            </ul>
        </div>

        <div class="status-card">
            <h3>üöÄ How It Works:</h3>
            <ol>
                <li><strong>Schema Validation</strong> - Checks all required columns for each table</li>
                <li><strong>Auto-Fix Missing Columns</strong> - Safely adds any missing columns with correct types</li>
                <li><strong>Comprehensive Testing</strong> - Validates that all fixes work correctly</li>
                <li><strong>Prevention System</strong> - Updates database service to prevent future errors</li>
            </ol>
        </div>

        <button class="fix-button" onclick="runComprehensiveFix()">
            üîß Run Comprehensive Fix (Permanent Solution)
        </button>
        
        <button class="fix-button" onclick="testAllColumns()">
            üß™ Test All Columns (Verification)
        </button>

        <div id="logContainer" class="log-container">
            <div class="info">üöÄ Ready to run comprehensive fix...</div>
            <div class="warning">‚ö†Ô∏è This will permanently resolve ALL column missing errors</div>
        </div>
    </div>

    <script>
        let logContainer = document.getElementById('logContainer');

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.className = type;
            div.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(div);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        async function runComprehensiveFix() {
            log('üöÄ Starting Comprehensive Column Fix...', 'info');
            log('=====================================', 'info');
            
            try {
                // Check if we have database service
                if (typeof window.dbService === 'undefined') {
                    log('‚ö†Ô∏è Database service not found. Loading...', 'warning');
                    await loadDatabaseService();
                }

                log('üìã Phase 1: Fixing stock_receiving_items table...', 'info');
                await fixStockReceivingItems();
                
                log('üìã Phase 2: Fixing vendor_payments table...', 'info');
                await fixVendorPayments();
                
                log('üìã Phase 3: Running comprehensive validation...', 'info');
                await validateAllTables();
                
                log('‚úÖ COMPREHENSIVE FIX COMPLETED SUCCESSFULLY!', 'success');
                log('üéâ All column missing errors have been permanently resolved!', 'success');
                log('üõ°Ô∏è Future database recreations will automatically include all required columns', 'success');
                
            } catch (error) {
                log(`‚ùå Error during comprehensive fix: ${error.message}`, 'error');
                console.error('Comprehensive fix error:', error);
            }
        }

        async function fixStockReceivingItems() {
            try {
                // Check if table exists
                const tableExists = await window.dbService.tableExists('stock_receiving_items');
                log(`üìä stock_receiving_items table exists: ${tableExists}`, 'info');
                
                if (!tableExists) {
                    log('üîß Creating stock_receiving_items table with correct schema...', 'warning');
                    // Table will be created by database service with all required columns
                    await window.dbService.ensureCriticalColumnsExist();
                } else {
                    // Get current table info
                    const tableInfo = await window.dbService.getTableSchema('stock_receiving_items');
                    const existingColumns = tableInfo.map(col => col.name);
                    log(`üìã Existing columns: ${existingColumns.join(', ')}`, 'info');
                    
                    // Required columns for stock_receiving_items
                    const requiredColumns = [
                        { name: 'expiry_date', type: 'TEXT' },
                        { name: 'notes', type: 'TEXT' }
                    ];
                    
                    for (const column of requiredColumns) {
                        if (!existingColumns.includes(column.name)) {
                            log(`üîß Adding missing column: ${column.name}`, 'warning');
                            const added = await window.dbService.safeAddColumn('stock_receiving_items', column.name, column.type);
                            if (added) {
                                log(`‚úÖ Successfully added ${column.name} to stock_receiving_items`, 'success');
                            } else {
                                log(`‚ùå Failed to add ${column.name} to stock_receiving_items`, 'error');
                            }
                        } else {
                            log(`‚úÖ Column ${column.name} already exists in stock_receiving_items`, 'success');
                        }
                    }
                }
                
                log('‚úÖ stock_receiving_items table fix completed', 'success');
                
            } catch (error) {
                log(`‚ùå Error fixing stock_receiving_items: ${error.message}`, 'error');
                throw error;
            }
        }

        async function fixVendorPayments() {
            try {
                // Check if vendor_payments table exists
                const vendorPaymentsExists = await window.dbService.tableExists('vendor_payments');
                log(`üìä vendor_payments table exists: ${vendorPaymentsExists}`, 'info');
                
                if (!vendorPaymentsExists) {
                    log('üîß Creating vendor_payments table with correct schema...', 'warning');
                    
                    // Create vendor_payments table with centralized schema
                    const vendorPaymentsSchema = `
                      CREATE TABLE IF NOT EXISTS vendor_payments (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        vendor_id INTEGER NOT NULL,
                        vendor_name TEXT NOT NULL,
                        receiving_id INTEGER,
                        amount REAL NOT NULL CHECK (amount > 0),
                        payment_channel_id INTEGER NOT NULL DEFAULT 1,
                        payment_channel_name TEXT NOT NULL DEFAULT 'cash',
                        payment_method TEXT DEFAULT 'cash',
                        reference_number TEXT,
                        cheque_number TEXT,
                        cheque_date TEXT,
                        notes TEXT,
                        date TEXT NOT NULL,
                        time TEXT NOT NULL,
                        created_by TEXT DEFAULT 'system',
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (vendor_id) REFERENCES vendors(id) ON DELETE CASCADE ON UPDATE CASCADE,
                        FOREIGN KEY (receiving_id) REFERENCES stock_receiving(id) ON DELETE SET NULL ON UPDATE CASCADE,
                        FOREIGN KEY (payment_channel_id) REFERENCES payment_channels(id) ON DELETE RESTRICT ON UPDATE CASCADE
                      )
                    `;
                    
                    await window.dbService.dbConnection.execute(vendorPaymentsSchema);
                    log('‚úÖ Created vendor_payments table with ALL required columns', 'success');
                    
                } else {
                    log('üîß vendor_payments table exists, checking for missing columns...', 'info');
                    
                    // Get current table info
                    const tableInfo = await window.dbService.getTableSchema('vendor_payments');
                    const existingColumns = tableInfo.map(col => col.name);
                    log(`üìã Existing columns: ${existingColumns.join(', ')}`, 'info');
                    
                    // Critical columns that must exist
                    const requiredColumns = [
                        { name: 'payment_channel_id', type: 'INTEGER NOT NULL DEFAULT 1' },
                        { name: 'payment_channel_name', type: 'TEXT NOT NULL DEFAULT "cash"' },
                        { name: 'vendor_name', type: 'TEXT NOT NULL DEFAULT ""' },
                        { name: 'reference_number', type: 'TEXT' },
                        { name: 'date', type: 'TEXT NOT NULL DEFAULT ""' },
                        { name: 'time', type: 'TEXT NOT NULL DEFAULT ""' }
                    ];
                    
                    for (const column of requiredColumns) {
                        if (!existingColumns.includes(column.name)) {
                            log(`üîß Adding missing column: ${column.name}`, 'warning');
                            try {
                                const added = await window.dbService.safeAddColumn('vendor_payments', column.name, column.type);
                                if (added) {
                                    log(`‚úÖ Added ${column.name} to vendor_payments`, 'success');
                                } else {
                                    log(`‚ùå Failed to add ${column.name} to vendor_payments`, 'error');
                                }
                            } catch (error) {
                                log(`‚ùå Failed to add ${column.name} to vendor_payments: ${error.message}`, 'error');
                            }
                        } else {
                            log(`‚úÖ Column ${column.name} already exists in vendor_payments`, 'success');
                        }
                    }
                }
                
                // Verify vendor_payments table has all required columns
                const finalTableInfo = await window.dbService.getTableSchema('vendor_payments');
                const finalColumns = finalTableInfo.map(col => col.name);
                const criticalColumns = ['payment_channel_id', 'payment_channel_name', 'vendor_name', 'reference_number', 'date', 'time'];
                const missingColumns = criticalColumns.filter(col => !finalColumns.includes(col));
                
                if (missingColumns.length === 0) {
                    log('‚úÖ vendor_payments table has ALL required columns', 'success');
                } else {
                    log(`‚ùå vendor_payments still missing columns: ${missingColumns.join(', ')}`, 'error');
                }
                
            } catch (error) {
                log(`‚ùå Error fixing vendor_payments table: ${error.message}`, 'error');
                throw error;
            }
        }

        async function validateAllTables() {
            try {
                log('üß™ Running comprehensive table validation...', 'info');
                
                // Validate stock_receiving_items
                log('üìä Testing stock_receiving_items columns...', 'info');
                const stockQuery = `SELECT expiry_date, notes FROM stock_receiving_items LIMIT 1`;
                try {
                    await window.dbService.dbConnection.execute(stockQuery);
                    log('‚úÖ stock_receiving_items.expiry_date and notes columns working', 'success');
                } catch (error) {
                    log(`‚ùå stock_receiving_items validation failed: ${error.message}`, 'error');
                }
                
                // Validate vendor_payments
                log('üìä Testing vendor_payments columns...', 'info');
                const vendorQuery = `SELECT payment_channel_id, payment_channel_name, reference_number FROM vendor_payments LIMIT 1`;
                try {
                    await window.dbService.dbConnection.execute(vendorQuery);
                    log('‚úÖ vendor_payments.payment_channel_id, payment_channel_name, and reference_number columns working', 'success');
                } catch (error) {
                    log(`‚ùå vendor_payments validation failed: ${error.message}`, 'error');
                }
                
                log('üéâ Comprehensive validation completed!', 'success');
                
            } catch (error) {
                log(`‚ùå Error during validation: ${error.message}`, 'error');
                throw error;
            }
        }

        async function loadDatabaseService() {
            return new Promise((resolve) => {
                log('üìö Loading database service...', 'info');
                // Wait for database service to be available
                const checkService = setInterval(() => {
                    if (typeof window.dbService !== 'undefined') {
                        clearInterval(checkService);
                        log('‚úÖ Database service loaded successfully', 'success');
                        resolve();
                    }
                }, 100);
                
                // Timeout after 10 seconds
                setTimeout(() => {
                    clearInterval(checkService);
                    log('‚ö†Ô∏è Database service not found - please ensure your app is running', 'warning');
                    resolve();
                }, 10000);
            });
        }

        async function testAllColumns() {
            log('üß™ Testing all column fixes...', 'info');
            log('=====================================', 'info');
            
            try {
                if (typeof window.dbService === 'undefined') {
                    log('‚ö†Ô∏è Database service not found. Please ensure your app is running.', 'warning');
                    return;
                }
                
                // Test each problematic column
                const tests = [
                    {
                        name: 'stock_receiving_items.expiry_date',
                        query: 'SELECT expiry_date FROM stock_receiving_items LIMIT 1'
                    },
                    {
                        name: 'stock_receiving_items.notes',
                        query: 'SELECT notes FROM stock_receiving_items LIMIT 1'
                    },
                    {
                        name: 'vendor_payments.payment_channel_id',
                        query: 'SELECT payment_channel_id FROM vendor_payments LIMIT 1'
                    },
                    {
                        name: 'vendor_payments.reference_number',
                        query: 'SELECT reference_number FROM vendor_payments LIMIT 1'
                    }
                ];
                
                for (const test of tests) {
                    try {
                        await window.dbService.dbConnection.execute(test.query);
                        log(`‚úÖ ${test.name} - Column exists and working`, 'success');
                    } catch (error) {
                        log(`‚ùå ${test.name} - ${error.message}`, 'error');
                    }
                }
                
                log('üéâ Column testing completed!', 'success');
                
            } catch (error) {
                log(`‚ùå Error during testing: ${error.message}`, 'error');
                console.error('Testing error:', error);
            }
        }

        // Auto-load check
        window.addEventListener('load', () => {
            log('üöÄ Comprehensive Column Fix Tool Ready', 'success');
            log('üí° This tool provides a permanent solution for all column missing errors', 'info');
            log('üõ°Ô∏è After running the fix, your database will automatically include all required columns', 'info');
        });
    </script>
</body>
</html>
