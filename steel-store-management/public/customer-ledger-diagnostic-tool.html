<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customer Ledger Outstanding Balance Diagnostic</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .alert-info {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        
        .alert-success {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .alert-warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .alert-error {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .tool-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 5px solid #3498db;
        }
        
        .button {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }
        
        .button.danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }
        
        .button.success {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }
        
        .button.warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }
        
        .input-group {
            margin: 10px 0;
        }
        
        .input-group input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            width: 200px;
            font-size: 16px;
        }
        
        .output-box {
            background: #2d3436;
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            white-space: pre-wrap;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        
        .problem-indicator {
            background: linear-gradient(135deg, #ff7675, #d63031);
            animation: pulse 2s infinite;
        }
        
        .healthy-indicator {
            background: linear-gradient(135deg, #00b894, #00cec9);
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .progress-bar {
            background: #ecf0f1;
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            height: 100%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Customer Ledger Outstanding Balance Diagnostic</h1>
        
        <div class="alert-info">
            <h2>üéØ DIAGNOSTIC TOOL OBJECTIVES</h2>
            <p><strong>Purpose:</strong> Check and fix outstanding balance calculations in customer ledger</p>
            <p><strong>Scope:</strong> Balance accuracy, event listeners, account summary calculations</p>
            <p><strong>Safe:</strong> Non-destructive analysis with optional fixes</p>
        </div>
        
        <div class="tool-section">
            <h3>üß™ Quick Diagnostic Tests</h3>
            <button class="button" onclick="runFullDiagnostic()">üîç Run Full Diagnostic</button>
            <button class="button" onclick="checkBalanceAccuracy()">üìä Check Balance Accuracy</button>
            <button class="button" onclick="testEventListeners()">üì° Test Event Listeners</button>
            <button class="button success" onclick="testAccountSummary()">üßÆ Test Account Summary</button>
        </div>
        
        <div class="tool-section">
            <h3>üîß Fix Operations</h3>
            <button class="button warning" onclick="fixAllBalances()">üîß Fix All Balance Discrepancies</button>
            <div class="input-group">
                <label>Fix Specific Customer:</label>
                <input type="number" id="customerIdInput" placeholder="Customer ID">
                <button class="button" onclick="fixSpecificCustomer()">Fix Customer</button>
            </div>
        </div>
        
        <div class="stats-grid" id="statsContainer">
            <div class="stat-card">
                <h3>System Status</h3>
                <div id="systemStatus">Checking...</div>
            </div>
            <div class="stat-card">
                <h3>Balance Issues</h3>
                <div id="balanceIssues">-</div>
            </div>
            <div class="stat-card">
                <h3>Event Listeners</h3>
                <div id="eventListeners">-</div>
            </div>
            <div class="stat-card">
                <h3>Last Check</h3>
                <div id="lastCheck">Never</div>
            </div>
        </div>
        
        <div class="tool-section">
            <h3>üìã Diagnostic Progress</h3>
            <div id="progressContainer" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
                <div id="progressText">Starting diagnostic...</div>
            </div>
        </div>
        
        <div class="tool-section">
            <h3>üîç Detailed Analysis</h3>
            <button class="button" onclick="showCustomerBalanceReport()">üìä Customer Balance Report</button>
            <button class="button" onclick="showEventListenerReport()">üì° Event Listener Report</button>
            <button class="button" onclick="showLedgerIntegrityReport()">üîí Ledger Integrity Report</button>
        </div>
        
        <div id="output" class="output-box">
üîç Customer Ledger Outstanding Balance Diagnostic Tool Ready
=====================================================

COMMON ISSUES THIS TOOL ADDRESSES:
‚ùå Outstanding balance showing incorrect amounts
‚ùå Customer balance not updating in real-time
‚ùå Discrepancy between ledger entries and stored balance
‚ùå Event listeners not triggering UI updates

DIAGNOSTIC FEATURES:
‚úÖ Balance accuracy verification
‚úÖ Event listener functionality testing  
‚úÖ Account summary calculation validation
‚úÖ Automatic fixes for common issues

Click "Run Full Diagnostic" to start comprehensive analysis.
        </div>
    </div>

    <script>
        let db;
        let diagnosticResults = {
            systemHealthy: false,
            balanceIssues: 0,
            eventListeners: 0,
            lastCheck: null
        };
        
        async function initDB() {
            if (!db) {
                const { DatabaseService } = await import('/src/services/database.ts');
                db = new DatabaseService();
            }
        }
        
        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : 'üìã';
            output.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }
        
        function updateStats() {
            document.getElementById('systemStatus').textContent = diagnosticResults.systemHealthy ? 'Healthy ‚úÖ' : 'Issues Found ‚ö†Ô∏è';
            document.getElementById('balanceIssues').textContent = diagnosticResults.balanceIssues;
            document.getElementById('eventListeners').textContent = diagnosticResults.eventListeners;
            document.getElementById('lastCheck').textContent = diagnosticResults.lastCheck || 'Never';
            
            // Update stat card colors
            const systemCard = document.getElementById('systemStatus').closest('.stat-card');
            systemCard.className = `stat-card ${diagnosticResults.systemHealthy ? 'healthy-indicator' : 'problem-indicator'}`;
        }
        
        function showProgress(show = true, text = '', percentage = 0) {
            const container = document.getElementById('progressContainer');
            const fill = document.getElementById('progressFill');
            const textEl = document.getElementById('progressText');
            
            container.style.display = show ? 'block' : 'none';
            if (show) {
                fill.style.width = percentage + '%';
                textEl.textContent = text;
            }
        }
        
        async function runFullDiagnostic() {
            await initDB();
            
            log('üéØ STARTING FULL CUSTOMER LEDGER DIAGNOSTIC...');
            log('=' * 50);
            
            showProgress(true, 'Initializing diagnostic...', 0);
            
            try {
                // Step 1: Check balance accuracy
                showProgress(true, 'Checking balance accuracy...', 25);
                const balanceResult = await checkBalanceAccuracyInternal();
                
                // Step 2: Test event listeners
                showProgress(true, 'Testing event listeners...', 50);
                const eventResult = await testEventListenersInternal();
                
                // Step 3: Test account summary
                showProgress(true, 'Testing account summary...', 75);
                const summaryResult = await testAccountSummaryInternal();
                
                // Step 4: Final analysis
                showProgress(true, 'Completing analysis...', 100);
                
                diagnosticResults = {
                    systemHealthy: balanceResult.success && eventResult.success && summaryResult.success && balanceResult.issuesFound === 0,
                    balanceIssues: balanceResult.issuesFound || 0,
                    eventListeners: eventResult.success ? Object.values(eventResult.listenerCounts || {}).reduce((a, b) => a + b, 0) : 0,
                    lastCheck: new Date().toLocaleString()
                };
                
                updateStats();
                
                log('\nüèÅ FULL DIAGNOSTIC COMPLETE');
                log(`üìä Balance Issues Found: ${diagnosticResults.balanceIssues}`);
                log(`üì° Active Event Listeners: ${diagnosticResults.eventListeners}`);
                log(`üéØ System Health: ${diagnosticResults.systemHealthy ? 'HEALTHY ‚úÖ' : 'NEEDS ATTENTION ‚ö†Ô∏è'}`);
                
                if (diagnosticResults.systemHealthy) {
                    log('üéâ Customer ledger system is working correctly!', 'success');
                } else {
                    log('‚ö†Ô∏è Issues found - use fix operations to resolve', 'warning');
                }
                
            } catch (error) {
                log(`‚ùå Diagnostic failed: ${error.message}`, 'error');
            } finally {
                showProgress(false);
            }
        }
        
        async function checkBalanceAccuracy() {
            await initDB();
            log('üìä Checking customer balance accuracy...');
            
            try {
                const result = await checkBalanceAccuracyInternal();
                
                if (result.success) {
                    log(`‚úÖ Balance accuracy check complete`, 'success');
                    log(`   Customers checked: ${result.customersChecked}`);
                    log(`   Issues found: ${result.issuesFound}`);
                    
                    if (result.issuesFound > 0) {
                        log('‚ö†Ô∏è Balance discrepancies found - use "Fix All Balance Discrepancies" to resolve', 'warning');
                    }
                } else {
                    log(`‚ùå Balance accuracy check failed: ${result.message}`, 'error');
                }
                
                diagnosticResults.balanceIssues = result.issuesFound || 0;
                updateStats();
                
            } catch (error) {
                log(`‚ùå Error checking balance accuracy: ${error.message}`, 'error');
            }
        }
        
        async function checkBalanceAccuracyInternal() {
            const customers = await db.safeSelect(`
                SELECT 
                  c.id,
                  c.name,
                  c.balance as stored_balance,
                  COALESCE(SUM(CASE WHEN l.entry_type = 'debit' THEN l.amount ELSE 0 END), 0) as ledger_debits,
                  COALESCE(SUM(CASE WHEN l.entry_type = 'credit' THEN l.amount ELSE 0 END), 0) as ledger_credits,
                  COALESCE(SUM(CASE WHEN l.entry_type = 'debit' THEN l.amount ELSE -l.amount END), 0) as calculated_balance,
                  ABS(c.balance - COALESCE(SUM(CASE WHEN l.entry_type = 'debit' THEN l.amount ELSE -l.amount END), 0)) as discrepancy
                FROM customers c
                LEFT JOIN customer_ledger_entries l ON c.id = l.customer_id
                GROUP BY c.id, c.name, c.balance
                ORDER BY discrepancy DESC
                LIMIT 10
            `);
            
            let issuesFound = 0;
            
            customers.forEach(customer => {
                if (customer.discrepancy > 0.01) {
                    issuesFound++;
                    log(`   ‚ö†Ô∏è ${customer.name}: Discrepancy Rs.${customer.discrepancy.toFixed(2)}`);
                }
            });
            
            return {
                success: true,
                customersChecked: customers.length,
                issuesFound: issuesFound,
                customers: customers
            };
        }
        
        async function testEventListeners() {
            log('üì° Testing event listener functionality...');
            
            try {
                const result = await testEventListenersInternal();
                
                if (result.success) {
                    log('‚úÖ Event listener test complete', 'success');
                    log(`   Test event worked: ${result.testEventWorked ? 'YES' : 'NO'}`);
                    log(`   Total active listeners: ${Object.values(result.listenerCounts).reduce((a, b) => a + b, 0)}`);
                    
                    Object.entries(result.listenerCounts).forEach(([event, count]) => {
                        const status = count > 0 ? '‚úÖ' : '‚ö†Ô∏è';
                        log(`   ${status} ${event}: ${count} listeners`);
                    });
                } else {
                    log(`‚ùå Event listener test failed: ${result.message}`, 'error');
                }
                
                diagnosticResults.eventListeners = result.success ? Object.values(result.listenerCounts || {}).reduce((a, b) => a + b, 0) : 0;
                updateStats();
                
            } catch (error) {
                log(`‚ùå Error testing event listeners: ${error.message}`, 'error');
            }
        }
        
        async function testEventListenersInternal() {
            // Import EventBus
            const eventModule = await import('/src/utils/eventBus.ts');
            const eventBus = eventModule.eventBus;
            const BUSINESS_EVENTS = eventModule.BUSINESS_EVENTS;
            
            // Test event emission
            let testEventReceived = false;
            const testHandler = (data) => {
                testEventReceived = true;
            };
            
            eventBus.on('DIAGNOSTIC_TEST_EVENT', testHandler);
            eventBus.emit('DIAGNOSTIC_TEST_EVENT', { test: true });
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            eventBus.off('DIAGNOSTIC_TEST_EVENT', testHandler);
            
            // Check listener counts
            const eventListenerCounts = {
                CUSTOMER_BALANCE_UPDATED: eventBus.getListenerCount(BUSINESS_EVENTS.CUSTOMER_BALANCE_UPDATED) || 0,
                CUSTOMER_LEDGER_UPDATED: eventBus.getListenerCount(BUSINESS_EVENTS.CUSTOMER_LEDGER_UPDATED) || 0,
                INVOICE_CREATED: eventBus.getListenerCount(BUSINESS_EVENTS.INVOICE_CREATED) || 0,
                PAYMENT_RECORDED: eventBus.getListenerCount(BUSINESS_EVENTS.PAYMENT_RECORDED) || 0
            };
            
            return {
                success: true,
                testEventWorked: testEventReceived,
                listenerCounts: eventListenerCounts
            };
        }
        
        async function testAccountSummary() {
            await initDB();
            log('üßÆ Testing account summary calculation...');
            
            try {
                const result = await testAccountSummaryInternal();
                
                if (result.success) {
                    log(`‚úÖ Account summary test complete`, 'success');
                    log(`   Test customer ID: ${result.testCustomerId}`);
                    log(`   Calculation correct: ${result.calculationCorrect ? 'YES' : 'NO'}`);
                    
                    if (result.calculationCorrect) {
                        log('üéâ Outstanding balance calculation is accurate!', 'success');
                    } else {
                        log('‚ö†Ô∏è Outstanding balance calculation has discrepancies', 'warning');
                    }
                } else {
                    log(`‚ùå Account summary test failed: ${result.message}`, 'error');
                }
                
            } catch (error) {
                log(`‚ùå Error testing account summary: ${error.message}`, 'error');
            }
        }
        
        async function testAccountSummaryInternal() {
            // Find a customer with transactions
            const customerWithTransactions = await db.safeSelect(`
                SELECT c.id, c.name, COUNT(l.id) as transaction_count
                FROM customers c
                LEFT JOIN customer_ledger_entries l ON c.id = l.customer_id
                GROUP BY c.id, c.name
                HAVING transaction_count > 0
                ORDER BY transaction_count DESC
                LIMIT 1
            `);
            
            if (customerWithTransactions.length === 0) {
                return { success: false, message: 'No customers with transactions found' };
            }
            
            const testCustomerId = customerWithTransactions[0].id;
            
            // Manual calculation
            const manualCalculation = await db.safeSelect(`
                SELECT 
                  COUNT(CASE WHEN entry_type = 'debit' AND transaction_type = 'invoice' THEN 1 END) as invoice_count,
                  COALESCE(SUM(CASE WHEN entry_type = 'debit' AND transaction_type = 'invoice' THEN amount ELSE 0 END), 0) as total_invoiced,
                  COALESCE(SUM(CASE WHEN entry_type = 'credit' AND transaction_type = 'payment' THEN amount ELSE 0 END), 0) as total_paid,
                  COALESCE(SUM(CASE WHEN entry_type = 'debit' THEN amount ELSE -amount END), 0) as outstanding_balance
                FROM customer_ledger_entries 
                WHERE customer_id = ?
            `, [testCustomerId]);
            
            const manual = manualCalculation[0];
            
            // Test via database service
            const accountSummary = await db.getCustomerAccountSummary(testCustomerId);
            
            // Compare results
            const invoicedMatch = Math.abs(manual.total_invoiced - accountSummary.totalInvoicedAmount) < 0.01;
            const paidMatch = Math.abs(manual.total_paid - accountSummary.totalPaidAmount) < 0.01;
            const outstandingMatch = Math.abs(manual.outstanding_balance - accountSummary.outstandingAmount) < 0.01;
            const countMatch = manual.invoice_count === accountSummary.totalInvoicesCount;
            
            const allMatch = invoicedMatch && paidMatch && outstandingMatch && countMatch;
            
            return {
                success: true,
                testCustomerId: testCustomerId,
                calculationCorrect: allMatch,
                manual: manual,
                service: accountSummary
            };
        }
        
        async function fixAllBalances() {
            await initDB();
            
            if (!confirm('‚ö†Ô∏è This will fix balance discrepancies for all customers. Continue?')) {
                return;
            }
            
            log('üîß Fixing all customer balance discrepancies...');
            
            try {
                const customersWithIssues = await db.safeSelect(`
                    SELECT 
                      c.id,
                      c.name,
                      c.balance as stored_balance,
                      COALESCE(SUM(CASE WHEN l.entry_type = 'debit' THEN l.amount ELSE -l.amount END), 0) as calculated_balance,
                      ABS(c.balance - COALESCE(SUM(CASE WHEN l.entry_type = 'debit' THEN l.amount ELSE -l.amount END), 0)) as discrepancy
                    FROM customers c
                    LEFT JOIN customer_ledger_entries l ON c.id = l.customer_id
                    GROUP BY c.id, c.name, c.balance
                    HAVING discrepancy > 0.01
                    ORDER BY discrepancy DESC
                `);
                
                log(`Found ${customersWithIssues.length} customers with balance discrepancies`);
                
                let fixedCount = 0;
                
                for (const customer of customersWithIssues) {
                    try {
                        const oldBalance = customer.stored_balance || 0;
                        const newBalance = customer.calculated_balance;
                        
                        await db.execute(
                            "UPDATE customers SET balance = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
                            [newBalance, customer.id]
                        );
                        
                        log(`‚úÖ ${customer.name}: ${oldBalance.toFixed(2)} ‚Üí ${newBalance.toFixed(2)}`);
                        fixedCount++;
                        
                    } catch (error) {
                        log(`‚ùå Failed to fix ${customer.name}: ${error.message}`, 'error');
                    }
                }
                
                log(`üéâ Fixed ${fixedCount}/${customersWithIssues.length} customer balances`, 'success');
                
                diagnosticResults.balanceIssues = Math.max(0, customersWithIssues.length - fixedCount);
                updateStats();
                
            } catch (error) {
                log(`‚ùå Error fixing balances: ${error.message}`, 'error');
            }
        }
        
        async function fixSpecificCustomer() {
            await initDB();
            
            const customerId = parseInt(document.getElementById('customerIdInput').value);
            
            if (!customerId) {
                log('‚ö†Ô∏è Please enter a valid Customer ID', 'warning');
                return;
            }
            
            log(`üîß Fixing balance for Customer ID ${customerId}...`);
            
            try {
                // Get customer info
                const customer = await db.safeSelect('SELECT * FROM customers WHERE id = ?', [customerId]);
                
                if (customer.length === 0) {
                    log(`‚ùå Customer ID ${customerId} not found`, 'error');
                    return;
                }
                
                // Calculate correct balance
                const calculation = await db.safeSelect(`
                    SELECT 
                      COALESCE(SUM(CASE WHEN entry_type = 'debit' THEN amount ELSE -amount END), 0) as calculated_balance
                    FROM customer_ledger_entries 
                    WHERE customer_id = ?
                `, [customerId]);
                
                const newBalance = calculation[0]?.calculated_balance || 0;
                const oldBalance = customer[0].balance || 0;
                
                // Update balance
                await db.execute(
                    "UPDATE customers SET balance = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
                    [newBalance, customerId]
                );
                
                log(`‚úÖ ${customer[0].name}: ${oldBalance.toFixed(2)} ‚Üí ${newBalance.toFixed(2)}`, 'success');
                
                // Test account summary
                const summary = await db.getCustomerAccountSummary(customerId);
                log(`üìä Updated outstanding balance: Rs.${summary.outstandingAmount.toFixed(2)}`);
                
            } catch (error) {
                log(`‚ùå Error fixing customer: ${error.message}`, 'error');
            }
        }
        
        async function showCustomerBalanceReport() {
            await initDB();
            
            log('üìä CUSTOMER BALANCE REPORT');
            log('=' * 40);
            
            try {
                const customers = await db.safeSelect(`
                    SELECT 
                      c.id,
                      c.name,
                      c.balance as stored_balance,
                      COALESCE(SUM(CASE WHEN l.entry_type = 'debit' THEN l.amount ELSE 0 END), 0) as total_debits,
                      COALESCE(SUM(CASE WHEN l.entry_type = 'credit' THEN l.amount ELSE 0 END), 0) as total_credits,
                      COALESCE(SUM(CASE WHEN l.entry_type = 'debit' THEN l.amount ELSE -l.amount END), 0) as calculated_balance,
                      ABS(c.balance - COALESCE(SUM(CASE WHEN l.entry_type = 'debit' THEN l.amount ELSE -l.amount END), 0)) as discrepancy
                    FROM customers c
                    LEFT JOIN customer_ledger_entries l ON c.id = l.customer_id
                    GROUP BY c.id, c.name, c.balance
                    ORDER BY c.name
                    LIMIT 20
                `);
                
                customers.forEach((customer, index) => {
                    const status = customer.discrepancy > 0.01 ? '‚ö†Ô∏è' : '‚úÖ';
                    log(`${index + 1}. ${status} ${customer.name} (ID: ${customer.id})`);
                    log(`   Stored: Rs.${(customer.stored_balance || 0).toFixed(2)}, Calculated: Rs.${customer.calculated_balance.toFixed(2)}`);
                    log(`   Ledger: Dr.${customer.total_debits.toFixed(2)}, Cr.${customer.total_credits.toFixed(2)}`);
                    if (customer.discrepancy > 0.01) {
                        log(`   ‚ö†Ô∏è DISCREPANCY: Rs.${customer.discrepancy.toFixed(2)}`);
                    }
                    log('');
                });
                
            } catch (error) {
                log(`‚ùå Error generating report: ${error.message}`, 'error');
            }
        }
        
        async function showEventListenerReport() {
            log('üì° EVENT LISTENER REPORT');
            log('=' * 30);
            
            try {
                const eventModule = await import('/src/utils/eventBus.ts');
                const eventBus = eventModule.eventBus;
                const BUSINESS_EVENTS = eventModule.BUSINESS_EVENTS;
                
                const allCounts = eventBus.getListenerCount();
                
                log('Active Event Listeners:');
                Object.entries(allCounts).forEach(([event, count]) => {
                    const status = count > 0 ? '‚úÖ' : '‚ö†Ô∏è';
                    log(`   ${status} ${event}: ${count} listeners`);
                });
                
                const totalListeners = Object.values(allCounts).reduce((a, b) => a + b, 0);
                log(`\nTotal Active Listeners: ${totalListeners}`);
                
            } catch (error) {
                log(`‚ùå Error generating event listener report: ${error.message}`, 'error');
            }
        }
        
        async function showLedgerIntegrityReport() {
            await initDB();
            
            log('üîí LEDGER INTEGRITY REPORT');
            log('=' * 35);
            
            try {
                // Check for orphaned ledger entries
                const orphanedEntries = await db.safeSelect(`
                    SELECT COUNT(*) as count
                    FROM customer_ledger_entries l
                    LEFT JOIN customers c ON l.customer_id = c.id
                    WHERE c.id IS NULL
                `);
                
                log(`Orphaned ledger entries: ${orphanedEntries[0].count}`);
                
                // Check for customers without ledger entries
                const customersWithoutEntries = await db.safeSelect(`
                    SELECT COUNT(*) as count
                    FROM customers c
                    LEFT JOIN customer_ledger_entries l ON c.id = l.customer_id
                    WHERE l.customer_id IS NULL
                `);
                
                log(`Customers without ledger entries: ${customersWithoutEntries[0].count}`);
                
                // Check for zero-amount entries (potential issues)
                const zeroAmountEntries = await db.safeSelect(`
                    SELECT COUNT(*) as count
                    FROM customer_ledger_entries
                    WHERE amount = 0 OR amount IS NULL
                `);
                
                log(`Zero-amount ledger entries: ${zeroAmountEntries[0].count}`);
                
                // Check for duplicate entries
                const duplicateEntries = await db.safeSelect(`
                    SELECT COUNT(*) - COUNT(DISTINCT customer_id, amount, entry_type, transaction_type, date) as duplicates
                    FROM customer_ledger_entries
                `);
                
                log(`Potential duplicate entries: ${duplicateEntries[0].duplicates}`);
                
                log('\n‚úÖ Ledger integrity check complete');
                
            } catch (error) {
                log(`‚ùå Error generating ledger integrity report: ${error.message}`, 'error');
            }
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            log('üîç Customer Ledger Outstanding Balance Diagnostic Tool Ready');
            log('üìã Use the buttons above to run diagnostic tests and fixes');
            updateStats();
        });
    </script>
</body>
</html>
