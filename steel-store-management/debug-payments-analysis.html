<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Payments Analysis</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .query-result { background: #f9f9f9; padding: 10px; margin: 10px 0; border-radius: 3px; }
        .error { color: red; }
        .success { color: green; }
        .warning { color: orange; }
        button { padding: 10px 15px; margin: 5px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:hover { background: #0056b3; }
        table { border-collapse: collapse; width: 100%; margin: 10px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background: #f2f2f2; }
        .count { font-weight: bold; font-size: 1.2em; }
    </style>
</head>
<body>
    <h1>üîç Payment Analysis Debug Tool</h1>
    
    <div class="section">
        <h2>üìä Database Table Counts</h2>
        <button onclick="checkTableCounts()">Check All Table Counts</button>
        <div id="tableCounts" class="query-result"></div>
    </div>

    <div class="section">
        <h2>üí≥ Payment Channels Analysis</h2>
        <button onclick="analyzePaymentChannels()">Analyze Payment Channels</button>
        <div id="paymentChannelsAnalysis" class="query-result"></div>
    </div>

    <div class="section">
        <h2>üí∞ Recent Payments Analysis</h2>
        <button onclick="analyzeRecentPayments()">Check Recent Payments</button>
        <div id="recentPaymentsAnalysis" class="query-result"></div>
    </div>

    <div class="section">
        <h2>üßæ Recent Invoices Analysis</h2>
        <button onclick="analyzeRecentInvoices()">Check Recent Invoices</button>
        <div id="recentInvoicesAnalysis" class="query-result"></div>
    </div>

    <div class="section">
        <h2>üîó Payment Channel Linkage Analysis</h2>
        <button onclick="analyzePaymentChannelLinkage()">Check Payment-Channel Linkage</button>
        <div id="paymentChannelLinkage" class="query-result"></div>
    </div>

    <div class="section">
        <h2>üõ†Ô∏è Fix Payment Channel Links</h2>
        <button onclick="fixPaymentChannelLinks()">Auto-Fix Payment Channel Links</button>
        <div id="fixResults" class="query-result"></div>
    </div>

    <script>
        const { invoke } = window.__TAURI__.tauri;

        async function executeQuery(query, params = []) {
            try {
                const result = await invoke('execute_sql', { 
                    query: query,
                    params: params 
                });
                return result;
            } catch (error) {
                console.error('Query error:', error);
                return { error: error.toString() };
            }
        }

        async function checkTableCounts() {
            const div = document.getElementById('tableCounts');
            div.innerHTML = '<p>Checking table counts...</p>';
            
            const tables = [
                'invoices', 'payments', 'enhanced_payments', 'payment_channels', 
                'customer_ledger_entries', 'customers', 'invoice_payments'
            ];
            
            let html = '<h3>Table Record Counts:</h3><table><tr><th>Table</th><th>Count</th><th>Status</th></tr>';
            
            for (const table of tables) {
                try {
                    const result = await executeQuery(`SELECT COUNT(*) as count FROM ${table}`);
                    if (result.error) {
                        html += `<tr><td>${table}</td><td class="error">ERROR</td><td class="error">${result.error}</td></tr>`;
                    } else {
                        const count = result[0]?.count || 0;
                        const status = count > 0 ? 'Has Data' : 'Empty';
                        const cssClass = count > 0 ? 'success' : 'warning';
                        html += `<tr><td>${table}</td><td class="count ${cssClass}">${count}</td><td class="${cssClass}">${status}</td></tr>`;
                    }
                } catch (error) {
                    html += `<tr><td>${table}</td><td class="error">ERROR</td><td class="error">${error.toString()}</td></tr>`;
                }
            }
            html += '</table>';
            div.innerHTML = html;
        }

        async function analyzePaymentChannels() {
            const div = document.getElementById('paymentChannelsAnalysis');
            div.innerHTML = '<p>Analyzing payment channels...</p>';
            
            try {
                // Get payment channels with stats
                const channels = await executeQuery(`
                    SELECT 
                        pc.*,
                        COALESCE(stats.total_transactions, 0) as total_transactions,
                        COALESCE(stats.total_amount, 0) as total_amount
                    FROM payment_channels pc
                    LEFT JOIN (
                        SELECT 
                            payment_channel_id,
                            COUNT(*) as total_transactions,
                            SUM(amount) as total_amount
                        FROM payments 
                        WHERE payment_channel_id IS NOT NULL
                        GROUP BY payment_channel_id
                    ) stats ON pc.id = stats.payment_channel_id
                    ORDER BY pc.name ASC
                `);
                
                if (channels.error) {
                    div.innerHTML = `<p class="error">Error: ${channels.error}</p>`;
                    return;
                }
                
                let html = '<h3>Payment Channels with Transaction Stats:</h3>';
                html += '<table><tr><th>ID</th><th>Name</th><th>Type</th><th>Active</th><th>Transactions</th><th>Total Amount</th></tr>';
                
                for (const channel of channels) {
                    const activeStatus = channel.is_active ? 'Active' : 'Inactive';
                    const activeClass = channel.is_active ? 'success' : 'warning';
                    html += `<tr>
                        <td>${channel.id}</td>
                        <td>${channel.name}</td>
                        <td>${channel.type}</td>
                        <td class="${activeClass}">${activeStatus}</td>
                        <td class="count">${channel.total_transactions}</td>
                        <td class="count">Rs. ${channel.total_amount.toFixed(2)}</td>
                    </tr>`;
                }
                html += '</table>';
                div.innerHTML = html;
                
            } catch (error) {
                div.innerHTML = `<p class="error">Error: ${error.toString()}</p>`;
            }
        }

        async function analyzeRecentPayments() {
            const div = document.getElementById('recentPaymentsAnalysis');
            div.innerHTML = '<p>Analyzing recent payments...</p>';
            
            try {
                const payments = await executeQuery(`
                    SELECT 
                        p.*,
                        pc.name as channel_name,
                        pc.type as channel_type
                    FROM payments p
                    LEFT JOIN payment_channels pc ON p.payment_channel_id = pc.id
                    ORDER BY p.date DESC, p.time DESC
                    LIMIT 10
                `);
                
                if (payments.error) {
                    div.innerHTML = `<p class="error">Error: ${payments.error}</p>`;
                    return;
                }
                
                let html = '<h3>Recent 10 Payments:</h3>';
                if (payments.length === 0) {
                    html += '<p class="warning">No payments found in database!</p>';
                } else {
                    html += '<table><tr><th>ID</th><th>Customer</th><th>Amount</th><th>Method</th><th>Channel ID</th><th>Channel Name</th><th>Date</th><th>Invoice Ref</th></tr>';
                    
                    for (const payment of payments) {
                        const channelStatus = payment.payment_channel_id ? 'Linked' : 'Not Linked';
                        const channelClass = payment.payment_channel_id ? 'success' : 'warning';
                        html += `<tr>
                            <td>${payment.id || 'N/A'}</td>
                            <td>${payment.customer_name || 'N/A'}</td>
                            <td class="count">Rs. ${(payment.amount || 0).toFixed(2)}</td>
                            <td>${payment.payment_method || 'N/A'}</td>
                            <td class="${channelClass}">${payment.payment_channel_id || 'NULL'}</td>
                            <td class="${channelClass}">${payment.channel_name || 'N/A'}</td>
                            <td>${payment.date || 'N/A'}</td>
                            <td>${payment.reference_invoice_id || 'N/A'}</td>
                        </tr>`;
                    }
                    html += '</table>';
                }
                div.innerHTML = html;
                
            } catch (error) {
                div.innerHTML = `<p class="error">Error: ${error.toString()}</p>`;
            }
        }

        async function analyzeRecentInvoices() {
            const div = document.getElementById('recentInvoicesAnalysis');
            div.innerHTML = '<p>Analyzing recent invoices...</p>';
            
            try {
                const invoices = await executeQuery(`
                    SELECT 
                        i.*,
                        COUNT(p.id) as payment_count,
                        COALESCE(SUM(p.amount), 0) as total_payments
                    FROM invoices i
                    LEFT JOIN payments p ON i.id = p.reference_invoice_id
                    GROUP BY i.id
                    ORDER BY i.created_at DESC
                    LIMIT 10
                `);
                
                if (invoices.error) {
                    div.innerHTML = `<p class="error">Error: ${invoices.error}</p>`;
                    return;
                }
                
                let html = '<h3>Recent 10 Invoices with Payment Info:</h3>';
                if (invoices.length === 0) {
                    html += '<p class="warning">No invoices found in database!</p>';
                } else {
                    html += '<table><tr><th>Bill#</th><th>Customer</th><th>Grand Total</th><th>Payment Amount</th><th>Remaining</th><th>Status</th><th>Payment Records</th><th>Total Payments</th></tr>';
                    
                    for (const invoice of invoices) {
                        const statusClass = invoice.status === 'paid' ? 'success' : (invoice.status === 'partially_paid' ? 'warning' : 'error');
                        html += `<tr>
                            <td>${invoice.bill_number || 'N/A'}</td>
                            <td>${invoice.customer_name || 'N/A'}</td>
                            <td class="count">Rs. ${(invoice.grand_total || 0).toFixed(2)}</td>
                            <td class="count">Rs. ${(invoice.payment_amount || 0).toFixed(2)}</td>
                            <td class="count">Rs. ${(invoice.remaining_balance || 0).toFixed(2)}</td>
                            <td class="${statusClass}">${invoice.status || 'N/A'}</td>
                            <td class="count">${invoice.payment_count}</td>
                            <td class="count">Rs. ${(invoice.total_payments || 0).toFixed(2)}</td>
                        </tr>`;
                    }
                    html += '</table>';
                }
                div.innerHTML = html;
                
            } catch (error) {
                div.innerHTML = `<p class="error">Error: ${error.toString()}</p>`;
            }
        }

        async function analyzePaymentChannelLinkage() {
            const div = document.getElementById('paymentChannelLinkage');
            div.innerHTML = '<p>Analyzing payment channel linkage...</p>';
            
            try {
                // Check payments without channel links
                const unlinkedPayments = await executeQuery(`
                    SELECT 
                        COUNT(*) as count,
                        payment_method,
                        SUM(amount) as total_amount
                    FROM payments 
                    WHERE payment_channel_id IS NULL
                    GROUP BY payment_method
                    ORDER BY count DESC
                `);
                
                // Check available payment channels
                const availableChannels = await executeQuery(`
                    SELECT id, name, type FROM payment_channels WHERE is_active = 1
                `);
                
                let html = '<h3>Payment Channel Linkage Analysis:</h3>';
                
                if (unlinkedPayments.error) {
                    html += `<p class="error">Error checking unlinked payments: ${unlinkedPayments.error}</p>`;
                } else if (unlinkedPayments.length === 0) {
                    html += '<p class="success">‚úÖ All payments are linked to payment channels!</p>';
                } else {
                    html += '<h4 class="warning">‚ö†Ô∏è Unlinked Payments by Method:</h4>';
                    html += '<table><tr><th>Payment Method</th><th>Count</th><th>Total Amount</th></tr>';
                    for (const payment of unlinkedPayments) {
                        html += `<tr>
                            <td>${payment.payment_method}</td>
                            <td class="count warning">${payment.count}</td>
                            <td class="count warning">Rs. ${payment.total_amount.toFixed(2)}</td>
                        </tr>`;
                    }
                    html += '</table>';
                }
                
                if (availableChannels.error) {
                    html += `<p class="error">Error checking available channels: ${availableChannels.error}</p>`;
                } else {
                    html += '<h4>Available Payment Channels:</h4>';
                    html += '<table><tr><th>ID</th><th>Name</th><th>Type</th></tr>';
                    for (const channel of availableChannels) {
                        html += `<tr>
                            <td>${channel.id}</td>
                            <td>${channel.name}</td>
                            <td>${channel.type}</td>
                        </tr>`;
                    }
                    html += '</table>';
                }
                
                div.innerHTML = html;
                
            } catch (error) {
                div.innerHTML = `<p class="error">Error: ${error.toString()}</p>`;
            }
        }

        async function fixPaymentChannelLinks() {
            const div = document.getElementById('fixResults');
            div.innerHTML = '<p>Fixing payment channel links...</p>';
            
            try {
                let html = '<h3>Payment Channel Link Fix Results:</h3>';
                
                // Get all unlinked payments
                const unlinkedPayments = await executeQuery(`
                    SELECT id, payment_method FROM payments WHERE payment_channel_id IS NULL
                `);
                
                if (unlinkedPayments.error) {
                    html += `<p class="error">Error: ${unlinkedPayments.error}</p>`;
                    div.innerHTML = html;
                    return;
                }
                
                if (unlinkedPayments.length === 0) {
                    html += '<p class="success">‚úÖ No unlinked payments found!</p>';
                    div.innerHTML = html;
                    return;
                }
                
                let fixedCount = 0;
                let errorCount = 0;
                
                // Try to link each payment to a suitable channel
                for (const payment of unlinkedPayments) {
                    try {
                        // Find matching payment channel
                        const channelResult = await executeQuery(`
                            SELECT id FROM payment_channels 
                            WHERE (name = ? OR type = ? OR LOWER(name) = LOWER(?) OR LOWER(type) = LOWER(?))
                            AND is_active = 1
                            LIMIT 1
                        `, [payment.payment_method, payment.payment_method, payment.payment_method, payment.payment_method]);
                        
                        if (channelResult && channelResult.length > 0) {
                            const channelId = channelResult[0].id;
                            
                            // Update the payment
                            const updateResult = await executeQuery(`
                                UPDATE payments 
                                SET payment_channel_id = ?, payment_channel_name = ?
                                WHERE id = ?
                            `, [channelId, payment.payment_method, payment.id]);
                            
                            if (!updateResult.error) {
                                fixedCount++;
                            } else {
                                errorCount++;
                                console.error('Update error:', updateResult.error);
                            }
                        } else {
                            // Create a new payment channel for this method
                            const createResult = await executeQuery(`
                                INSERT INTO payment_channels (name, type, description, is_active)
                                VALUES (?, ?, ?, 1)
                            `, [payment.payment_method, payment.payment_method.toLowerCase(), `Auto-created channel for ${payment.payment_method} payments`]);
                            
                            if (!createResult.error && createResult.lastInsertId) {
                                const newChannelId = createResult.lastInsertId;
                                
                                // Update the payment with new channel
                                const updateResult = await executeQuery(`
                                    UPDATE payments 
                                    SET payment_channel_id = ?, payment_channel_name = ?
                                    WHERE id = ?
                                `, [newChannelId, payment.payment_method, payment.id]);
                                
                                if (!updateResult.error) {
                                    fixedCount++;
                                } else {
                                    errorCount++;
                                }
                            } else {
                                errorCount++;
                            }
                        }
                    } catch (error) {
                        console.error('Fix error for payment', payment.id, ':', error);
                        errorCount++;
                    }
                }
                
                html += `<p class="success">‚úÖ Fixed ${fixedCount} payment channel links</p>`;
                if (errorCount > 0) {
                    html += `<p class="error">‚ùå ${errorCount} payments could not be fixed</p>`;
                }
                
                // Re-run the analysis to show updated results
                html += '<h4>Updated Payment Channel Analysis:</h4>';
                const updatedChannels = await executeQuery(`
                    SELECT 
                        pc.name,
                        COUNT(p.id) as payment_count,
                        SUM(p.amount) as total_amount
                    FROM payment_channels pc
                    LEFT JOIN payments p ON pc.id = p.payment_channel_id
                    WHERE pc.is_active = 1
                    GROUP BY pc.id, pc.name
                    ORDER BY payment_count DESC
                `);
                
                if (!updatedChannels.error) {
                    html += '<table><tr><th>Channel</th><th>Payments</th><th>Total Amount</th></tr>';
                    for (const channel of updatedChannels) {
                        html += `<tr>
                            <td>${channel.name}</td>
                            <td class="count">${channel.payment_count}</td>
                            <td class="count">Rs. ${(channel.total_amount || 0).toFixed(2)}</td>
                        </tr>`;
                    }
                    html += '</table>';
                }
                
                div.innerHTML = html;
                
            } catch (error) {
                div.innerHTML = `<p class="error">Error: ${error.toString()}</p>`;
            }
        }

        // Auto-run basic analysis on page load
        window.onload = function() {
            checkTableCounts();
        };
    </script>
</body>
</html>
