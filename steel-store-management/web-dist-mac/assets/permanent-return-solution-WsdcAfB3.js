const b=`
  CREATE TABLE IF NOT EXISTS returns (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    return_number TEXT UNIQUE NOT NULL,
    original_invoice_id INTEGER NOT NULL,
    original_invoice_number TEXT NOT NULL,
    customer_id INTEGER NOT NULL,
    customer_name TEXT NOT NULL,
    return_type TEXT NOT NULL DEFAULT 'partial' CHECK (return_type IN ('full', 'partial', 'exchange')),
    reason TEXT NOT NULL,
    total_items INTEGER DEFAULT 0,
    total_quantity REAL DEFAULT 0,
    subtotal REAL NOT NULL DEFAULT 0,
    discount_amount REAL DEFAULT 0,
    tax_amount REAL DEFAULT 0,
    total_amount REAL NOT NULL DEFAULT 0,
    refund_amount REAL DEFAULT 0,
    refund_method TEXT CHECK (refund_method IN ('cash', 'bank', 'store_credit', 'exchange')),
    settlement_type TEXT NOT NULL DEFAULT 'ledger' CHECK (settlement_type IN ('ledger', 'cash')),
    settlement_amount REAL DEFAULT 0,
    settlement_processed INTEGER DEFAULT 0,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected', 'completed', 'cancelled')),
    quality_check TEXT DEFAULT 'pending' CHECK (quality_check IN ('pending', 'passed', 'failed')),
    date TEXT NOT NULL,
    time TEXT NOT NULL,
    processed_date TEXT,
    notes TEXT,
    internal_notes TEXT,
    approved_by TEXT,
    processed_by TEXT,
    created_by TEXT NOT NULL DEFAULT 'system',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (original_invoice_id) REFERENCES invoices(id) ON DELETE RESTRICT,
    FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE RESTRICT
  )
`,v=`
  CREATE TABLE IF NOT EXISTS return_items (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    return_id INTEGER NOT NULL,
    original_invoice_item_id INTEGER NOT NULL,
    product_id INTEGER NOT NULL,
    product_name TEXT NOT NULL,
    original_quantity REAL NOT NULL,
    return_quantity REAL NOT NULL,
    unit TEXT NOT NULL,
    unit_price REAL NOT NULL,
    total_price REAL NOT NULL,
    condition_status TEXT DEFAULT 'good' CHECK (condition_status IN ('good', 'damaged', 'expired', 'defective')),
    reason TEXT,
    action TEXT DEFAULT 'refund' CHECK (action IN ('refund', 'exchange', 'repair', 'dispose')),
    restocked INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (return_id) REFERENCES returns(id) ON DELETE CASCADE,
    FOREIGN KEY (original_invoice_item_id) REFERENCES invoice_items(id) ON DELETE RESTRICT,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE RESTRICT
  )
`;class y{static validateReturnData(e){const t=[];return(!e.customer_id||e.customer_id<=0)&&t.push("Valid customer_id is required"),(!e.original_invoice_id||e.original_invoice_id<=0)&&t.push("Valid original_invoice_id is required (fixes NOT NULL constraint)"),(!e.items||!Array.isArray(e.items)||e.items.length===0)&&t.push("At least one return item is required"),(!e.reason||e.reason.trim().length===0)&&t.push("Return reason is required"),["ledger","cash"].includes(e.settlement_type)||t.push('Settlement type must be either "ledger" or "cash"'),e.items&&Array.isArray(e.items)&&e.items.forEach((n,i)=>{(!n.product_id||n.product_id<=0)&&t.push(`Item ${i+1}: Valid product_id is required`),(!n.original_invoice_item_id||n.original_invoice_item_id<=0)&&t.push(`Item ${i+1}: Valid original_invoice_item_id is required`),(!n.return_quantity||n.return_quantity<=0)&&t.push(`Item ${i+1}: Return quantity must be greater than 0`),n.return_quantity>n.original_quantity&&t.push(`Item ${i+1}: Return quantity cannot exceed original quantity`)}),{valid:t.length===0,errors:t}}}class U{dbConnection;constructor(e){this.dbConnection=e}async getInvoicePaymentStatus(e){try{const t=await this.dbConnection.select("SELECT id, total_amount, paid_amount, remaining_balance, payment_status FROM invoices WHERE id = ?",[e]);if(!t||t.length===0)throw new Error(`Invoice with ID ${e} not found`);const n=t[0],i=n.total_amount||0,s=n.paid_amount||0,o=n.remaining_balance||i-s,a=s>=i&&o<=.01,r=s>0&&s<i,c=s<=0;return{invoice_id:e,total_amount:i,paid_amount:s,remaining_balance:o,payment_status:n.payment_status||"pending",is_fully_paid:a,is_partially_paid:r,is_unpaid:c}}catch(t){throw console.error("Error getting invoice payment status:",t),t}}determineSettlementEligibility(e,t){if(e.is_fully_paid)return{eligible_for_credit:!0,credit_amount:t,reason:"Invoice is fully paid - full credit eligible"};if(e.is_partially_paid){const n=e.paid_amount/e.total_amount,i=t*n;return{eligible_for_credit:i>0,credit_amount:i,reason:`Invoice is partially paid (${(n*100).toFixed(1)}%) - partial credit eligible`}}else return{eligible_for_credit:!1,credit_amount:0,reason:"Invoice is unpaid - no credit eligible"}}}class S{dbConnection;constructor(e){this.dbConnection=e}async updateInvoiceForReturn(e,t,n){try{console.log(`🔄 Updating invoice ${e} to reflect returns...`),await this.createNegativeEntriesForReturns(e,t,n);for(const i of t.items)await this.updateInvoiceItemForReturn(i.original_invoice_item_id,i.return_quantity,n);await this.recalculateInvoiceTotals(e),await this.addReturnNotesToInvoice(e,t,n),console.log(`✅ Invoice ${e} updated successfully for returns`)}catch(i){throw console.error("Error updating invoice for return:",i),i}}async createNegativeEntriesForReturns(e,t,n){try{console.log(`📝 Creating negative entries for returned items in invoice ${e}...`);const s=(await this.dbConnection.select("PRAGMA table_info(invoice_items)")).map(o=>o.name);for(const o of t.items){const a=["invoice_id","product_name","quantity","unit_price"],r=[e,`[RETURNED] ${o.product_name}`,-o.return_quantity,o.unit_price];s.includes("product_id")&&o.product_id&&(a.push("product_id"),r.push(o.product_id)),s.includes("unit")&&(a.push("unit"),r.push(o.unit||"piece")),s.includes("rate")&&(a.push("rate"),r.push(o.unit_price)),s.includes("line_total")&&(a.push("line_total"),r.push(-o.total_price)),s.includes("total_price")&&(a.push("total_price"),r.push(-o.total_price)),s.includes("amount")&&(a.push("amount"),r.push(-o.total_price)),s.includes("notes")&&(a.push("notes"),r.push(`Returned item - Return ID: ${n}, Reason: ${o.reason||t.reason}`)),s.includes("product_description")&&(a.push("product_description"),r.push(`Return of ${o.return_quantity} units`)),s.includes("is_misc_item")&&(a.push("is_misc_item"),r.push(1)),s.includes("created_at")&&(a.push("created_at"),r.push("CURRENT_TIMESTAMP")),s.includes("updated_at")&&(a.push("updated_at"),r.push("CURRENT_TIMESTAMP"));const c=r.map(m=>m==="CURRENT_TIMESTAMP"?"CURRENT_TIMESTAMP":"?"),u=r.filter(m=>m!=="CURRENT_TIMESTAMP"),l=`
                    INSERT INTO invoice_items (${a.join(", ")})
                    VALUES (${c.join(", ")})
                `;await this.dbConnection.execute(l,u),console.log(`✅ Created negative entry for returned item: ${o.product_name} (${-o.return_quantity} units)`)}console.log(`✅ Created ${t.items.length} negative entries for returns`)}catch(i){console.error("Error creating negative entries for returns:",i),console.log(`⚠️ Continuing without creating negative entries for invoice ${e}`)}}async updateInvoiceItemForReturn(e,t,n){try{const s=(await this.dbConnection.select("PRAGMA table_info(invoice_items)")).some(u=>u.name==="notes"),o=await this.dbConnection.select(s?"SELECT quantity, notes FROM invoice_items WHERE id = ?":"SELECT quantity FROM invoice_items WHERE id = ?",[e]);if(!o||o.length===0)throw new Error(`Invoice item ${e} not found`);const a=o[0],r=a.quantity,c=r-t;if(s){const u=a.notes||"",l=`[RETURNED] ${t} units returned (Return ID: ${n})`,m=u?`${u}
${l}`:l;await this.dbConnection.execute(`
                    UPDATE invoice_items 
                    SET quantity = ?, notes = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                `,[c,m,e])}else await this.dbConnection.execute(`
                    UPDATE invoice_items 
                    SET quantity = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                `,[c,e]),console.log("⚠️ Notes column not available in invoice_items table - return tracking limited");console.log(`✅ Updated invoice item ${e}: quantity ${r} → ${c}`)}catch(i){throw console.error("Error updating invoice item for return:",i),i}}async recalculateInvoiceTotals(e){try{const n=(await this.dbConnection.select("PRAGMA table_info(invoice_items)")).map(d=>d.name),i=n.includes("line_total"),s=n.includes("total_price"),o=n.includes("amount"),a=n.includes("id"),r=["quantity","unit_price"];i&&r.push("line_total"),a&&r.push("id");const c=await this.dbConnection.select(`SELECT ${r.join(", ")} FROM invoice_items WHERE invoice_id = ?`,[e]);if(!c||c.length===0){console.log(`No items found for invoice ${e}`);return}let u=0,l=0,m=0;for(const d of c){const R=d.quantity*d.unit_price;if(u+=R,l+=1,m+=d.quantity,a&&(i||s||o)){const p=[],g=[];i&&(p.push("line_total = ?"),g.push(R)),s&&(p.push("total_price = ?"),g.push(R)),o&&(p.push("amount = ?"),g.push(R)),p.length>0&&(g.push(e,d.id),await this.dbConnection.execute(`UPDATE invoice_items SET ${p.join(", ")} WHERE invoice_id = ? AND id = ?`,g))}else console.log("⚠️ Cannot update item totals - required columns not available")}const E=(await this.dbConnection.select("PRAGMA table_info(invoices)")).map(d=>d.name),h=["id"];E.includes("discount_amount")&&h.push("discount_amount"),E.includes("tax_amount")&&h.push("tax_amount"),E.includes("paid_amount")&&h.push("paid_amount");const C=await this.dbConnection.select(`SELECT ${h.join(", ")} FROM invoices WHERE id = ?`,[e]);if(C&&C.length>0){const d=C[0],R=d.discount_amount||0,p=d.tax_amount||0,g=d.paid_amount||0,N=u-R+p,A=N,L=N-g,_=[],T=[];E.includes("subtotal")&&(_.push("subtotal = ?"),T.push(u)),E.includes("total_amount")&&(_.push("total_amount = ?"),T.push(N)),E.includes("grand_total")&&(_.push("grand_total = ?"),T.push(A)),E.includes("remaining_balance")&&(_.push("remaining_balance = ?"),T.push(L)),E.includes("total_items")&&(_.push("total_items = ?"),T.push(l)),E.includes("total_quantity")&&(_.push("total_quantity = ?"),T.push(m)),E.includes("updated_at")&&_.push("updated_at = CURRENT_TIMESTAMP"),_.length>0?(T.push(e),await this.dbConnection.execute(`UPDATE invoices SET ${_.join(", ")} WHERE id = ?`,T),console.log(`✅ Recalculated invoice ${e} totals: subtotal = ${u}, total = ${N}`)):console.log("⚠️ Cannot update invoice totals - no updatable columns found")}}catch(t){console.error("Error recalculating invoice totals:",t),console.log(`⚠️ Continuing without recalculating totals for invoice ${e}`)}}async addReturnNotesToInvoice(e,t,n){try{if(!(await this.dbConnection.select("PRAGMA table_info(invoices)")).some(a=>a.name==="notes")){console.log("⚠️ Notes column not available in invoices table - return notes cannot be added");return}const o=await this.dbConnection.select("SELECT notes FROM invoices WHERE id = ?",[e]);if(o&&o.length>0){const a=o[0].notes||"",r=`[RETURN PROCESSED] Return ID: ${n}, Items: ${t.items.length}, Amount: Rs. ${t.items.reduce((u,l)=>u+l.total_price,0).toFixed(2)}, Reason: ${t.reason}`,c=a?`${a}
${r}`:r;await this.dbConnection.execute("UPDATE invoices SET notes = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?",[c,e]),console.log(`✅ Added return notes to invoice ${e}`)}}catch(i){console.error("Error adding return notes to invoice:",i),console.log(`⚠️ Continuing without adding notes to invoice ${e}`)}}}class M{dbConnection;constructor(e){this.dbConnection=e}async ensureReturnTablesExist(){try{console.log("🔧 [PERMANENT] Ensuring return tables exist..."),await this.dbConnection.execute(b),console.log("✅ [PERMANENT] Returns table ensured"),await this.dbConnection.execute(v),console.log("✅ [PERMANENT] Return_items table ensured"),console.log("✅ [PERMANENT] All return tables are ready")}catch(e){throw console.error("❌ [PERMANENT] Error ensuring return tables:",e),new Error(`Failed to ensure return tables exist: ${e instanceof Error?e.message:String(e)}`)}}async validateReturnTablesSchema(){try{const e=[],n=(await this.dbConnection.select("PRAGMA table_info(returns)")).map(l=>l.name),s=["id","return_number","original_invoice_id","original_invoice_number","customer_id","customer_name","settlement_type","settlement_amount"].filter(l=>!n.includes(l));s.length===0?e.push("✅ Returns table has all required columns"):e.push(`❌ Returns table missing columns: ${s.join(", ")}`);const a=(await this.dbConnection.select("PRAGMA table_info(return_items)")).map(l=>l.name),c=["id","return_id","original_invoice_item_id","product_id","return_quantity","unit_price","total_price"].filter(l=>!a.includes(l));return c.length===0?e.push("✅ Return_items table has all required columns"):e.push(`❌ Return_items table missing columns: ${c.join(", ")}`),{valid:s.length===0&&c.length===0,details:e}}catch(e){return{valid:!1,details:[`❌ Error validating schema: ${e instanceof Error?e.message:String(e)}`]}}}}console.log("📋 ENHANCED PERMANENT RETURN SYSTEM SOLUTION:");console.log("=============================================");console.log("1. ✅ Complete return data interface with required fields");console.log("2. ✅ Permanent table schemas with CREATE TABLE IF NOT EXISTS");console.log("3. ✅ Comprehensive validation to prevent NOT NULL constraint errors");console.log("4. ✅ Safe table creation that works on existing and new databases");console.log("5. ✅ Invoice payment status checking for credit eligibility");console.log("6. ✅ Smart credit allocation based on payment status");console.log("7. ✅ Invoice updates to reflect returned items");console.log("8. ✅ Automatic invoice recalculation after returns");console.log("9. ✅ No migrations, no ALTER TABLE, no manual scripts required");console.log("");console.log("🎯 NEW BUSINESS LOGIC:");console.log("• Fully Paid Invoice: Customer gets full credit for returns");console.log("• Partially Paid Invoice: Customer gets proportional credit");console.log("• Unpaid Invoice: No credit given for returns");console.log("• Invoice items are updated to show returned quantities");console.log("• Invoice totals are recalculated automatically");console.log("• Return notes are added to invoice for audit trail");console.log("");console.log("🚀 ENHANCED FEATURES:");console.log("• InvoicePaymentStatusManager: Checks payment status");console.log("• Smart credit eligibility determination");console.log("• InvoiceReturnUpdateManager: Updates invoice records");console.log("• Automatic quantity adjustments and total recalculation");console.log("• Complete audit trail with return tracking");console.log("");console.log("� USAGE: Import managers in database.ts for enhanced return processing");export{U as InvoicePaymentStatusManager,S as InvoiceReturnUpdateManager,b as PERMANENT_RETURNS_TABLE_SCHEMA,v as PERMANENT_RETURN_ITEMS_TABLE_SCHEMA,M as PermanentReturnTableManager,y as PermanentReturnValidator};
