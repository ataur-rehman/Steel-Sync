<!DOCTYPE html>
<html>

<head>
    <title>Complete Customer Balance Fix</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .success {
            color: green;
            font-weight: bold;
        }

        .error {
            color: red;
            font-weight: bold;
        }

        .warning {
            color: orange;
            font-weight: bold;
        }

        .info {
            color: blue;
        }

        button {
            padding: 12px 24px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-warning {
            background: #ffc107;
            color: black;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .log {
            background: #f8f9fa;
            padding: 15px;
            font-family: monospace;
            white-space: pre-wrap;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
        }

        .progress {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar {
            height: 100%;
            background: #007bff;
            transition: width 0.3s;
        }
    </style>
</head>

<body>
    <h1>üîß Complete Customer Balance Fix Tool</h1>
    <p class="info">This tool will fix all customer balance issues by removing fake sync entries and recalculating
        proper running balances.</p>

    <div class="section">
        <h2>üöÄ One-Click Fix All</h2>
        <button class="btn-success" onclick="fixAllBalanceIssues()">üîß Fix All Balance Issues</button>
        <button class="btn-primary" onclick="runDiagnostics()">üîç Run Diagnostics</button>
        <div id="mainResults"></div>
        <div class="progress" id="progressContainer" style="display: none;">
            <div class="progress-bar" id="progressBar"></div>
        </div>
    </div>

    <div class="section">
        <h2>üìä Manual Steps</h2>
        <button class="btn-warning" onclick="step1_cleanSync()">Step 1: Clean Sync Entries</button>
        <button class="btn-warning" onclick="step2_fixRunningBalances()">Step 2: Fix Running Balances</button>
        <button class="btn-warning" onclick="step3_updateCustomerBalances()">Step 3: Update Customer Balances</button>
        <div id="manualResults"></div>
    </div>

    <div class="section">
        <h2>üîç View Results</h2>
        <button class="btn-primary" onclick="showSampleLedger()">üìã Show Sample Ledger</button>
        <button class="btn-primary" onclick="checkConsistency()">‚úÖ Check Consistency</button>
        <div id="viewResults"></div>
    </div>

    <script type="module">
        let db;

        async function initializeDB() {
            try {
                const module = await import('./src/services/database.ts');
                db = new module.DatabaseService();
                await db.initialize();
                console.log('‚úÖ Database initialized');
                return true;
            } catch (error) {
                console.error('‚ùå Failed to initialize database:', error);
                document.getElementById('mainResults').innerHTML = `<p class="error">‚ùå Failed to initialize database: ${error.message}</p>`;
                return false;
            }
        }

        function updateProgress(percent) {
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            progressContainer.style.display = 'block';
            progressBar.style.width = percent + '%';

            if (percent >= 100) {
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 2000);
            }
        }

        function logToResults(containerId, message, type = 'info') {
            const container = document.getElementById(containerId);
            const logClass = type === 'error' ? 'error' :
                type === 'success' ? 'success' :
                    type === 'warning' ? 'warning' : 'info';
            container.innerHTML += `<p class="${logClass}">${message}</p>`;
            container.scrollTop = container.scrollHeight;
        }

        window.fixAllBalanceIssues = async function () {
            const results = document.getElementById('mainResults');
            results.innerHTML = '<h3>üîß Comprehensive Balance Fix</h3><div class="log" id="fixLog"></div>';

            if (!await initializeDB()) return;

            try {
                updateProgress(10);
                logToResults('fixLog', 'üßπ Step 1: Cleaning balance synchronization entries...', 'info');

                // Step 1: Clean balance sync entries
                const syncCount = await db.executeRawQuery(`
                    SELECT COUNT(*) as count FROM customer_ledger_entries 
                    WHERE description LIKE '%Balance synchronization%' 
                       OR description LIKE '%balance sync%'
                       OR description LIKE '%ledger sync%'
                       OR transaction_type = 'balance_sync'
                       OR transaction_type = 'balance_update'
                `);

                if (syncCount[0].count > 0) {
                    await db.executeRawQuery(`
                        DELETE FROM customer_ledger_entries 
                        WHERE description LIKE '%Balance synchronization%' 
                           OR description LIKE '%balance sync%'
                           OR description LIKE '%ledger sync%'
                           OR transaction_type = 'balance_sync'
                           OR transaction_type = 'balance_update'
                    `);
                    logToResults('fixLog', `‚úÖ Removed ${syncCount[0].count} fake balance sync entries`, 'success');
                } else {
                    logToResults('fixLog', '‚úÖ No balance sync entries found', 'success');
                }

                updateProgress(30);
                logToResults('fixLog', '‚ö° Step 2: Fixing running balances in ledger entries...', 'info');

                // Step 2: Fix running balances for all customers
                const customers = await db.executeRawQuery(`
                    SELECT id, name FROM customers ORDER BY id
                `);

                let fixedEntries = 0;
                for (const customer of customers) {
                    // Get all ledger entries for this customer in chronological order
                    const entries = await db.executeRawQuery(`
                        SELECT id, entry_type, amount, balance_before, balance_after, date, created_at
                        FROM customer_ledger_entries 
                        WHERE customer_id = ?
                        ORDER BY date ASC, created_at ASC
                    `, [customer.id]);

                    if (entries.length === 0) continue;

                    let runningBalance = 0;
                    for (let i = 0; i < entries.length; i++) {
                        const entry = entries[i];
                        const amount = parseFloat(entry.amount || 0);

                        const balanceBefore = runningBalance;
                        const balanceAfter = entry.entry_type === 'debit'
                            ? balanceBefore + amount
                            : balanceBefore - amount;

                        // Update if wrong
                        if (Math.abs((entry.balance_before || 0) - balanceBefore) > 0.01 ||
                            Math.abs((entry.balance_after || 0) - balanceAfter) > 0.01) {

                            await db.executeRawQuery(`
                                UPDATE customer_ledger_entries 
                                SET balance_before = ?, balance_after = ?
                                WHERE id = ?
                            `, [balanceBefore, balanceAfter, entry.id]);
                            fixedEntries++;
                        }

                        runningBalance = balanceAfter;
                    }
                }

                logToResults('fixLog', `‚úÖ Fixed running balances for ${customers.length} customers (${fixedEntries} entries updated)`, 'success');

                updateProgress(60);
                logToResults('fixLog', 'üîÑ Step 3: Updating customer balance table...', 'info');

                // Step 3: Update customer balances in customers table
                let balanceUpdates = 0;
                for (const customer of customers) {
                    const balanceResult = await db.executeRawQuery(`
                        SELECT 
                            COALESCE(SUM(CASE WHEN entry_type = 'debit' THEN amount ELSE -amount END), 0) as correct_balance
                        FROM customer_ledger_entries 
                        WHERE customer_id = ?
                    `, [customer.id]);

                    const correctBalance = parseFloat(balanceResult[0].correct_balance || 0);

                    await db.executeRawQuery(`
                        UPDATE customers 
                        SET balance = ?, updated_at = CURRENT_TIMESTAMP 
                        WHERE id = ?
                    `, [correctBalance, customer.id]);

                    balanceUpdates++;
                }

                logToResults('fixLog', `‚úÖ Updated balances for ${balanceUpdates} customers`, 'success');

                updateProgress(90);
                logToResults('fixLog', 'üîç Step 4: Final consistency check...', 'info');

                // Step 4: Verify consistency
                const inconsistencies = await db.executeRawQuery(`
                    SELECT COUNT(*) as count FROM (
                        SELECT 
                            c.id,
                            ABS(c.balance - COALESCE(SUM(CASE WHEN l.entry_type = 'debit' THEN l.amount ELSE -l.amount END), 0)) as difference
                        FROM customers c
                        LEFT JOIN customer_ledger_entries l ON c.id = l.customer_id
                        GROUP BY c.id, c.balance
                        HAVING ABS(difference) > 0.01
                    )
                `);

                updateProgress(100);

                if (inconsistencies[0].count === 0) {
                    logToResults('fixLog', 'üéâ ALL BALANCE ISSUES FIXED! All customer balances are now consistent.', 'success');
                } else {
                    logToResults('fixLog', `‚ö†Ô∏è Found ${inconsistencies[0].count} remaining inconsistencies. Manual review needed.`, 'warning');
                }

                logToResults('fixLog', '\nüîß CUSTOMER BALANCE FIX COMPLETED!\nYou can now check the customer ledger - balances should display correctly.', 'success');

            } catch (error) {
                logToResults('fixLog', `‚ùå Error during fix: ${error.message}`, 'error');
                console.error('Balance fix error:', error);
            }
        };

        window.runDiagnostics = async function () {
            const results = document.getElementById('mainResults');
            results.innerHTML = '<h3>üîç Balance Diagnostics</h3><div class="log" id="diagLog"></div>';

            if (!await initializeDB()) return;

            try {
                // Check for balance sync entries
                const syncEntries = await db.executeRawQuery(`
                    SELECT COUNT(*) as count FROM customer_ledger_entries 
                    WHERE description LIKE '%Balance synchronization%' 
                       OR description LIKE '%balance sync%'
                       OR transaction_type = 'balance_sync'
                `);

                logToResults('diagLog', `üìä Balance sync entries: ${syncEntries[0].count}`,
                    syncEntries[0].count > 0 ? 'warning' : 'success');

                // Check balance inconsistencies
                const inconsistencies = await db.executeRawQuery(`
                    SELECT COUNT(*) as count FROM (
                        SELECT 
                            c.id,
                            ABS(c.balance - COALESCE(SUM(CASE WHEN l.entry_type = 'debit' THEN l.amount ELSE -l.amount END), 0)) as difference
                        FROM customers c
                        LEFT JOIN customer_ledger_entries l ON c.id = l.customer_id
                        GROUP BY c.id, c.balance
                        HAVING ABS(difference) > 0.01
                    )
                `);

                logToResults('diagLog', `üìä Balance inconsistencies: ${inconsistencies[0].count}`,
                    inconsistencies[0].count > 0 ? 'warning' : 'success');

                // Check entries with wrong running balance
                const wrongRunningBalance = await db.executeRawQuery(`
                    SELECT COUNT(*) as count FROM customer_ledger_entries 
                    WHERE balance_before IS NULL OR balance_after IS NULL OR balance_after = 0
                `);

                logToResults('diagLog', `üìä Entries with wrong running balance: ${wrongRunningBalance[0].count}`,
                    wrongRunningBalance[0].count > 0 ? 'warning' : 'success');

                // Summary
                const totalIssues = syncEntries[0].count + inconsistencies[0].count + wrongRunningBalance[0].count;

                if (totalIssues === 0) {
                    logToResults('diagLog', '\n‚úÖ NO ISSUES FOUND! All balances are working correctly.', 'success');
                } else {
                    logToResults('diagLog', `\n‚ö†Ô∏è FOUND ${totalIssues} ISSUES. Click "Fix All Balance Issues" to resolve them.`, 'warning');
                }

            } catch (error) {
                logToResults('diagLog', `‚ùå Error during diagnostics: ${error.message}`, 'error');
            }
        };

        window.showSampleLedger = async function () {
            const results = document.getElementById('viewResults');
            results.innerHTML = '<h3>üìã Sample Customer Ledger</h3>';

            if (!await initializeDB()) return;

            try {
                const sampleEntries = await db.executeRawQuery(`
                    SELECT 
                        customer_name, entry_type, transaction_type, amount, description, 
                        balance_before, balance_after, date, time
                    FROM customer_ledger_entries 
                    ORDER BY created_at DESC 
                    LIMIT 10
                `);

                if (sampleEntries.length > 0) {
                    let table = '<table style="width: 100%; border-collapse: collapse;"><tr style="background: #f8f9fa;"><th style="padding: 8px; border: 1px solid #ddd;">Customer</th><th style="padding: 8px; border: 1px solid #ddd;">Type</th><th style="padding: 8px; border: 1px solid #ddd;">Amount</th><th style="padding: 8px; border: 1px solid #ddd;">Before</th><th style="padding: 8px; border: 1px solid #ddd;">After</th><th style="padding: 8px; border: 1px solid #ddd;">Date</th></tr>';

                    sampleEntries.forEach(entry => {
                        const balanceAfter = parseFloat(entry.balance_after || 0);
                        const color = balanceAfter === 0 ? 'background: #ffe6e6;' : '';
                        table += `<tr style="${color}">
                            <td style="padding: 8px; border: 1px solid #ddd;">${entry.customer_name}</td>
                            <td style="padding: 8px; border: 1px solid #ddd;">${entry.entry_type} (${entry.transaction_type})</td>
                            <td style="padding: 8px; border: 1px solid #ddd;">${parseFloat(entry.amount).toFixed(2)}</td>
                            <td style="padding: 8px; border: 1px solid #ddd;">${parseFloat(entry.balance_before || 0).toFixed(2)}</td>
                            <td style="padding: 8px; border: 1px solid #ddd;">${balanceAfter.toFixed(2)}</td>
                            <td style="padding: 8px; border: 1px solid #ddd;">${entry.date} ${entry.time}</td>
                        </tr>`;
                    });
                    table += '</table>';

                    results.innerHTML += table;
                    results.innerHTML += '<p class="info">Entries with red background have balance_after = 0 (problematic)</p>';
                } else {
                    results.innerHTML += '<p>No ledger entries found</p>';
                }

            } catch (error) {
                results.innerHTML += `<p class="error">‚ùå Error: ${error.message}</p>`;
            }
        };

        // Initialize when page loads
        initializeDB();
    </script>
</body>

</html>