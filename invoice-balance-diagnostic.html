<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîç Invoice Return/Edit/Delete Balance Issues Diagnostic</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #fff;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #dc3545, #6f42c1);
            border-radius: 10px;
        }

        .button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            font-family: inherit;
        }

        .button:hover {
            background-color: #0056b3;
        }

        .button.danger {
            background-color: #dc3545;
        }

        .button.danger:hover {
            background-color: #c82333;
        }

        .button.success {
            background-color: #28a745;
        }

        .button.success:hover {
            background-color: #218838;
        }

        .output {
            background-color: #2d2d2d;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 15px;
            margin-top: 20px;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            max-height: 700px;
            overflow-y: auto;
        }

        .success {
            color: #28a745;
            font-weight: bold;
        }

        .error {
            color: #dc3545;
            font-weight: bold;
        }

        .warning {
            color: #ffc107;
            font-weight: bold;
        }

        .info {
            color: #17a2b8;
        }

        .highlight {
            background-color: #4a5568;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .scenario {
            border: 1px solid #6f42c1;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            background-color: #2a2a2a;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üîç Invoice Balance Issues Diagnostic</h1>
            <p>Testing invoice calculations after returns, edits, and deletions</p>
            <p><strong>Scenario:</strong> Total 23000 ‚Üí Returned 10000 ‚Üí Remaining 13000 ‚Üí Payment 13000 ‚Üí Shows 10000
                outstanding</p>
        </div>

        <div>
            <button class="button danger" onclick="testReturnScenario()">
                üîÑ Test Return Scenario
            </button>
            <button class="button" onclick="testEditDeleteScenarios()">
                ‚úèÔ∏è Test Edit/Delete Scenarios
            </button>
            <button class="button" onclick="analyzeInvoiceCalculations()">
                üßÆ Analyze Invoice Calculations
            </button>
            <button class="button success" onclick="fixInvoiceBalanceIssues()">
                üîß Fix Balance Issues
            </button>
            <button class="button" onclick="clearOutput()">
                üóëÔ∏è Clear Output
            </button>
        </div>

        <div id="output" class="output">
            üéØ Ready to diagnose invoice balance calculation issues.

            <span class="highlight">Problem:</span> When products are returned/edited/deleted and then payments are
            made,
            the invoice shows incorrect outstanding balances in the invoice list.

            <span class="highlight">Test Scenario:</span>
            1. Invoice total: 23,000
            2. Products returned: 10,000
            3. Remaining should be: 13,000
            4. Payment added: 13,000
            5. Expected outstanding: 0
            6. Actual outstanding shown: 10,000 ‚ùå

            Click "Test Return Scenario" to start diagnosis...
        </div>
    </div>

    <script type="module">
        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            let className = '';

            if (type === 'error') className = 'error';
            else if (type === 'success') className = 'success';
            else if (type === 'warning') className = 'warning';
            else if (type === 'info') className = 'info';

            output.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span>\n`;
            output.scrollTop = output.scrollHeight;
        }

        window.testReturnScenario = async function () {
            log('üîÑ === TESTING RETURN SCENARIO ===', 'error');
            log('Scenario: Total 23000 ‚Üí Returned 10000 ‚Üí Payment 13000 ‚Üí Shows 10000 outstanding', 'info');

            try {
                const { db } = await import('./src/services/database.ts');
                if (!db?.dbConnection) {
                    log('‚ùå Database connection not available', 'error');
                    return;
                }
                log('‚úÖ Database connected', 'success');

                // Find invoices with returns and payments
                log('üîç Finding invoices with returns and payments...', 'info');

                const problematicInvoices = await db.dbConnection.select(`
                    SELECT 
                        i.id, i.bill_number, i.grand_total, i.payment_amount, i.remaining_balance,
                        COALESCE(returns.total_returned, 0) as total_returned,
                        COALESCE(i.grand_total - returns.total_returned, i.grand_total) as adjusted_total,
                        COALESCE(i.grand_total - returns.total_returned - i.payment_amount, i.remaining_balance) as calculated_remaining,
                        ABS(i.remaining_balance - (i.grand_total - COALESCE(returns.total_returned, 0) - i.payment_amount)) as balance_error,
                        c.name as customer_name
                    FROM invoices i
                    LEFT JOIN customers c ON i.customer_id = c.id
                    LEFT JOIN (
                        SELECT 
                            ri.original_invoice_id,
                            SUM(ri.return_quantity * ri.unit_price) as total_returned
                        FROM return_items ri
                        GROUP BY ri.original_invoice_id
                    ) returns ON i.id = returns.original_invoice_id
                    WHERE i.payment_amount > 0 
                      AND returns.total_returned > 0
                      AND ABS(i.remaining_balance - (i.grand_total - COALESCE(returns.total_returned, 0) - i.payment_amount)) > 0.01
                    ORDER BY balance_error DESC
                    LIMIT 10
                `);

                if (problematicInvoices.length === 0) {
                    log('‚úÖ No invoices found with return/payment calculation errors', 'success');
                } else {
                    log(`‚ö†Ô∏è Found ${problematicInvoices.length} invoices with calculation errors:`, 'warning');

                    problematicInvoices.forEach((invoice, index) => {
                        log(`\nüìÑ Invoice ${index + 1}: ${invoice.bill_number} (${invoice.customer_name})`, 'info');
                        log(`   Grand Total: ${invoice.grand_total}`, 'info');
                        log(`   Returned: ${invoice.total_returned}`, 'warning');
                        log(`   Payment: ${invoice.payment_amount}`, 'info');
                        log(`   Current Balance: ${invoice.remaining_balance}`, 'error');
                        log(`   Calculated Should Be: ${invoice.calculated_remaining}`, 'success');
                        log(`   Error Amount: ${invoice.balance_error}`, 'error');
                    });
                }

                // Test your specific scenario
                log('\nüéØ Testing for your specific scenario pattern...', 'info');
                const specificScenario = await db.dbConnection.select(`
                    SELECT 
                        i.id, i.bill_number, i.grand_total, i.payment_amount, i.remaining_balance,
                        COALESCE(returns.total_returned, 0) as total_returned,
                        c.name as customer_name
                    FROM invoices i
                    LEFT JOIN customers c ON i.customer_id = c.id
                    LEFT JOIN (
                        SELECT 
                            ri.original_invoice_id,
                            SUM(ri.return_quantity * ri.unit_price) as total_returned
                        FROM return_items ri
                        GROUP BY ri.original_invoice_id
                    ) returns ON i.id = returns.original_invoice_id
                    WHERE i.grand_total >= 20000 AND i.grand_total <= 25000
                      AND returns.total_returned >= 8000 AND returns.total_returned <= 12000
                      AND i.payment_amount >= 10000 AND i.payment_amount <= 15000
                      AND i.remaining_balance > 5000
                    LIMIT 5
                `);

                if (specificScenario.length > 0) {
                    log(`üéØ Found ${specificScenario.length} invoices matching your scenario pattern:`, 'warning');
                    specificScenario.forEach((invoice, index) => {
                        const expectedRemaining = invoice.grand_total - invoice.total_returned - invoice.payment_amount;
                        log(`\nüî¥ Matching Invoice ${index + 1}: ${invoice.bill_number}`, 'error');
                        log(`   Total: ${invoice.grand_total}`, 'info');
                        log(`   Returned: ${invoice.total_returned}`, 'warning');
                        log(`   Payment: ${invoice.payment_amount}`, 'info');
                        log(`   Shows Outstanding: ${invoice.remaining_balance}`, 'error');
                        log(`   Should Be Outstanding: ${expectedRemaining}`, 'success');
                        log(`   ERROR: Off by ${invoice.remaining_balance - expectedRemaining}`, 'error');
                    });
                } else {
                    log('‚ÑπÔ∏è No invoices found exactly matching your scenario pattern', 'info');
                }

            } catch (error) {
                log(`‚ùå Error testing return scenario: ${error.message}`, 'error');
                console.error('Return scenario error:', error);
            }
        };

        window.analyzeInvoiceCalculations = async function () {
            log('üßÆ === ANALYZING INVOICE CALCULATIONS ===', 'info');

            try {
                const { db } = await import('./src/services/database.ts');
                if (!db?.dbConnection) {
                    log('‚ùå Database connection not available', 'error');
                    return;
                }

                // Check if return_items table exists and its structure
                log('üîç Checking return_items table structure...', 'info');
                try {
                    const returnItemsSchema = await db.dbConnection.select("PRAGMA table_info(return_items)");
                    if (returnItemsSchema.length > 0) {
                        log('‚úÖ return_items table exists with columns:', 'success');
                        returnItemsSchema.forEach(col => {
                            log(`   ${col.name}: ${col.type}`, 'info');
                        });
                    } else {
                        log('‚ùå return_items table does not exist', 'error');
                        return;
                    }
                } catch (schemaError) {
                    log(`‚ùå Error checking return_items schema: ${schemaError.message}`, 'error');
                    return;
                }

                // Check triggers that handle invoice balance updates
                log('\nüîß Checking invoice balance triggers...', 'info');
                const triggers = await db.dbConnection.select(`
                    SELECT name, sql FROM sqlite_master 
                    WHERE type = 'trigger' 
                    AND (name LIKE '%invoice%' OR name LIKE '%return%' OR name LIKE '%payment%')
                    AND sql IS NOT NULL
                    ORDER BY name
                `);

                if (triggers.length > 0) {
                    log(`‚úÖ Found ${triggers.length} relevant triggers:`, 'success');
                    triggers.forEach(trigger => {
                        log(`   üìã ${trigger.name}`, 'info');
                        if (trigger.sql && trigger.sql.includes('remaining_balance')) {
                            log('      ‚úÖ Updates remaining_balance', 'success');
                        } else {
                            log('      ‚ö†Ô∏è May not update remaining_balance', 'warning');
                        }
                    });
                } else {
                    log('‚ùå No triggers found for invoice balance management', 'error');
                }

                // Test actual calculation logic
                log('\nüßÆ Testing calculation logic on sample invoices...', 'info');
                const sampleInvoices = await db.dbConnection.select(`
                    SELECT 
                        i.id, i.bill_number, i.grand_total, i.payment_amount, i.remaining_balance,
                        COALESCE(SUM(ri.return_quantity * ri.unit_price), 0) as total_returned
                    FROM invoices i
                    LEFT JOIN return_items ri ON i.id = ri.original_invoice_id
                    WHERE i.payment_amount > 0
                    GROUP BY i.id, i.bill_number, i.grand_total, i.payment_amount, i.remaining_balance
                    HAVING total_returned > 0
                    LIMIT 5
                `);

                if (sampleInvoices.length > 0) {
                    log(`üìä Analyzing ${sampleInvoices.length} sample invoices with returns and payments:`, 'info');

                    sampleInvoices.forEach((invoice, index) => {
                        const correctBalance = invoice.grand_total - invoice.total_returned - invoice.payment_amount;
                        const isCorrect = Math.abs(invoice.remaining_balance - correctBalance) <= 0.01;

                        log(`\nüìÑ Invoice ${index + 1}: ${invoice.bill_number}`, 'info');
                        log(`   Formula: ${invoice.grand_total} - ${invoice.total_returned} - ${invoice.payment_amount} = ${correctBalance}`, 'info');
                        log(`   Current Balance: ${invoice.remaining_balance}`, isCorrect ? 'success' : 'error');
                        log(`   Status: ${isCorrect ? '‚úÖ Correct' : '‚ùå Incorrect'}`, isCorrect ? 'success' : 'error');

                        if (!isCorrect) {
                            log(`   Error: Off by ${invoice.remaining_balance - correctBalance}`, 'error');
                        }
                    });
                } else {
                    log('‚ÑπÔ∏è No sample invoices found with both returns and payments', 'info');
                }

            } catch (error) {
                log(`‚ùå Error analyzing calculations: ${error.message}`, 'error');
                console.error('Analysis error:', error);
            }
        };

        window.testEditDeleteScenarios = async function () {
            log('‚úèÔ∏è === TESTING EDIT/DELETE SCENARIOS ===', 'info');

            try {
                const { db } = await import('./src/services/database.ts');
                if (!db?.dbConnection) {
                    log('‚ùå Database connection not available', 'error');
                    return;
                }

                // Check for invoices that might have been edited/deleted
                log('üîç Looking for potential edit/delete calculation issues...', 'info');

                // Find invoices where payment_amount is close to or exceeds grand_total but remaining_balance is not near zero
                const suspiciousInvoices = await db.dbConnection.select(`
                    SELECT 
                        i.id, i.bill_number, i.grand_total, i.payment_amount, i.remaining_balance,
                        ROUND(i.payment_amount / i.grand_total * 100, 2) as payment_percentage,
                        ABS(i.remaining_balance - (i.grand_total - i.payment_amount)) as balance_discrepancy,
                        c.name as customer_name
                    FROM invoices i
                    LEFT JOIN customers c ON i.customer_id = c.id
                    WHERE i.payment_amount >= (i.grand_total * 0.8)  -- Payment is 80%+ of total
                      AND i.remaining_balance > (i.grand_total * 0.1)  -- But remaining is still 10%+ of total
                      AND ABS(i.remaining_balance - (i.grand_total - i.payment_amount)) > 0.01
                    ORDER BY balance_discrepancy DESC
                    LIMIT 10
                `);

                if (suspiciousInvoices.length > 0) {
                    log(`‚ö†Ô∏è Found ${suspiciousInvoices.length} invoices with suspicious edit/delete patterns:`, 'warning');

                    suspiciousInvoices.forEach((invoice, index) => {
                        log(`\nüö® Suspicious Invoice ${index + 1}: ${invoice.bill_number} (${invoice.customer_name})`, 'warning');
                        log(`   Grand Total: ${invoice.grand_total}`, 'info');
                        log(`   Payment: ${invoice.payment_amount} (${invoice.payment_percentage}% of total)`, 'info');
                        log(`   Remaining Balance: ${invoice.remaining_balance}`, 'error');
                        log(`   Simple Calc Would Be: ${invoice.grand_total - invoice.payment_amount}`, 'success');
                        log(`   Discrepancy: ${invoice.balance_discrepancy}`, 'error');
                    });
                } else {
                    log('‚úÖ No suspicious edit/delete patterns found', 'success');
                }

                // Check for possible orphaned invoice items
                log('\nüîç Checking for invoice integrity issues...', 'info');

                const integrityCheck = await db.dbConnection.select(`
                    SELECT 
                        i.id, i.bill_number, i.grand_total,
                        COALESCE(SUM(ii.total_price), 0) as calculated_total,
                        ABS(i.grand_total - COALESCE(SUM(ii.total_price), 0)) as total_discrepancy,
                        COUNT(ii.id) as item_count
                    FROM invoices i
                    LEFT JOIN invoice_items ii ON i.id = ii.invoice_id
                    GROUP BY i.id, i.bill_number, i.grand_total
                    HAVING ABS(i.grand_total - COALESCE(SUM(ii.total_price), 0)) > 0.01
                    ORDER BY total_discrepancy DESC
                    LIMIT 10
                `);

                if (integrityCheck.length > 0) {
                    log(`‚ö†Ô∏è Found ${integrityCheck.length} invoices with total calculation mismatches:`, 'warning');

                    integrityCheck.forEach((invoice, index) => {
                        log(`\nüîß Integrity Issue ${index + 1}: ${invoice.bill_number}`, 'warning');
                        log(`   Stored Total: ${invoice.grand_total}`, 'info');
                        log(`   Calculated from Items: ${invoice.calculated_total}`, 'info');
                        log(`   Item Count: ${invoice.item_count}`, 'info');
                        log(`   Discrepancy: ${invoice.total_discrepancy}`, 'error');
                    });
                } else {
                    log('‚úÖ No invoice total integrity issues found', 'success');
                }

            } catch (error) {
                log(`‚ùå Error testing edit/delete scenarios: ${error.message}`, 'error');
                console.error('Edit/delete test error:', error);
            }
        };

        window.fixInvoiceBalanceIssues = async function () {
            log('üîß === FIXING INVOICE BALANCE ISSUES ===', 'success');

            try {
                const { db } = await import('./src/services/database.ts');
                if (!db?.dbConnection) {
                    log('‚ùå Database connection not available', 'error');
                    return;
                }

                log('üéØ Creating comprehensive invoice balance fix...', 'info');

                // Step 1: Fix invoices with return calculation errors
                log('\nüìã Step 1: Fixing return calculation errors...', 'info');

                const returnFixes = await db.dbConnection.execute(`
                    UPDATE invoices 
                    SET remaining_balance = ROUND(
                        grand_total - 
                        COALESCE((
                            SELECT SUM(ri.return_quantity * ri.unit_price) 
                            FROM return_items ri 
                            WHERE ri.original_invoice_id = invoices.id
                        ), 0) - 
                        COALESCE(payment_amount, 0), 
                        2
                    )
                    WHERE id IN (
                        SELECT i.id
                        FROM invoices i
                        LEFT JOIN (
                            SELECT 
                                ri.original_invoice_id,
                                SUM(ri.return_quantity * ri.unit_price) as total_returned
                            FROM return_items ri
                            GROUP BY ri.original_invoice_id
                        ) returns ON i.id = returns.original_invoice_id
                        WHERE returns.total_returned > 0
                          AND ABS(i.remaining_balance - (i.grand_total - COALESCE(returns.total_returned, 0) - i.payment_amount)) > 0.01
                    )
                `);

                log(`‚úÖ Fixed ${returnFixes.changes} invoices with return calculation errors`, 'success');

                // Step 2: Fix invoices with simple payment calculation errors
                log('\nüìã Step 2: Fixing payment calculation errors...', 'info');

                const paymentFixes = await db.dbConnection.execute(`
                    UPDATE invoices 
                    SET remaining_balance = ROUND(grand_total - COALESCE(payment_amount, 0), 2)
                    WHERE ABS(remaining_balance - (grand_total - COALESCE(payment_amount, 0))) > 0.01
                      AND id NOT IN (
                          SELECT DISTINCT ri.original_invoice_id 
                          FROM return_items ri 
                          WHERE ri.original_invoice_id = invoices.id
                      )
                `);

                log(`‚úÖ Fixed ${paymentFixes.changes} invoices with payment calculation errors`, 'success');

                // Step 3: Fix invoice totals that don't match their items
                log('\nüìã Step 3: Fixing invoice total mismatches...', 'info');

                const totalFixes = await db.dbConnection.execute(`
                    UPDATE invoices 
                    SET 
                        grand_total = (
                            SELECT COALESCE(SUM(ii.total_price), 0) 
                            FROM invoice_items ii 
                            WHERE ii.invoice_id = invoices.id
                        ),
                        remaining_balance = ROUND(
                            (
                                SELECT COALESCE(SUM(ii.total_price), 0) 
                                FROM invoice_items ii 
                                WHERE ii.invoice_id = invoices.id
                            ) - 
                            COALESCE((
                                SELECT SUM(ri.return_quantity * ri.unit_price) 
                                FROM return_items ri 
                                WHERE ri.original_invoice_id = invoices.id
                            ), 0) - 
                            COALESCE(payment_amount, 0), 
                            2
                        )
                    WHERE ABS(grand_total - (
                        SELECT COALESCE(SUM(ii.total_price), 0) 
                        FROM invoice_items ii 
                        WHERE ii.invoice_id = invoices.id
                    )) > 0.01
                `);

                log(`‚úÖ Fixed ${totalFixes.changes} invoices with total calculation mismatches`, 'success');

                // Step 4: Update customer balances
                log('\nüìã Step 4: Updating customer balances...', 'info');

                const customerUpdates = await db.dbConnection.execute(`
                    UPDATE customers 
                    SET 
                        balance = ROUND((
                            SELECT COALESCE(SUM(i.remaining_balance), 0) 
                            FROM invoices i 
                            WHERE i.customer_id = customers.id
                        ), 2),
                        status = CASE 
                            WHEN (
                                SELECT COALESCE(SUM(i.remaining_balance), 0) 
                                FROM invoices i 
                                WHERE i.customer_id = customers.id
                            ) <= 0.01 THEN 'Clear'
                            ELSE 'Outstanding'
                        END
                `);

                log(`‚úÖ Updated ${customerUpdates.changes} customer balances`, 'success');

                // Step 5: Verification
                log('\nüìä Step 5: Verifying fixes...', 'info');

                const verification = await db.dbConnection.select(`
                    SELECT 
                        COUNT(*) as total_invoices,
                        SUM(CASE WHEN remaining_balance < 0 THEN 1 ELSE 0 END) as negative_balances,
                        SUM(CASE WHEN ABS(remaining_balance - ROUND(remaining_balance, 2)) > 0.001 THEN 1 ELSE 0 END) as precision_errors
                    FROM invoices
                `);

                const verifyResult = verification[0];
                log(`üìä Verification Results:`, 'info');
                log(`   Total Invoices: ${verifyResult.total_invoices}`, 'info');
                log(`   Negative Balances: ${verifyResult.negative_balances}`, verifyResult.negative_balances > 0 ? 'warning' : 'success');
                log(`   Precision Errors: ${verifyResult.precision_errors}`, verifyResult.precision_errors > 0 ? 'warning' : 'success');

                if (verifyResult.negative_balances === 0 && verifyResult.precision_errors === 0) {
                    log('\nüéâ ALL INVOICE BALANCE ISSUES FIXED SUCCESSFULLY!', 'success');
                    log('üí° Your scenario (23000 ‚Üí returned 10000 ‚Üí payment 13000) should now show 0 outstanding', 'success');
                } else {
                    log('\n‚ö†Ô∏è Some issues may still exist. Run analysis again to check.', 'warning');
                }

            } catch (error) {
                log(`‚ùå Error fixing balance issues: ${error.message}`, 'error');
                console.error('Fix error:', error);
            }
        };

        window.clearOutput = function () {
            document.getElementById('output').innerHTML = 'Output cleared. Ready for next test.\n';
        };

        // Initialize
        log('üîç Invoice balance diagnostic tool ready', 'success');
        log('üí° This tool will help identify and fix the specific issue you described', 'info');
    </script>
</body>

</html>