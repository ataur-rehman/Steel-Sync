<!DOCTYPE html>
<html>

<head>
    <title>üîß Customer Balance Audit & Fix Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
        }

        .alert {
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }

        .alert-danger {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .alert-info {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .alert-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 11px;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 6px;
            text-align: left;
        }

        th {
            background: #f8f9fa;
            font-weight: bold;
            position: sticky;
            top: 0;
        }

        .wrong {
            background: #ffebee;
        }

        .fixed {
            background: #e8f5e8;
        }

        .warning {
            background: #fff3cd;
        }

        button {
            padding: 12px 24px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-warning {
            background: #ffc107;
            color: black;
        }

        .calculation-box {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #007bff;
        }

        .progress {
            background: #e9ecef;
            border-radius: 5px;
            height: 25px;
            margin: 10px 0;
        }

        .progress-bar {
            background: #007bff;
            height: 100%;
            border-radius: 5px;
            transition: width 0.3s;
        }

        .customer-row {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üîß Customer Balance Audit & Fix Tool</h1>

        <div class="alert alert-warning">
            <h3>‚ö†Ô∏è COMPREHENSIVE BALANCE AUDIT</h3>
            <p>This tool will check ALL customers for balance calculation issues and fix them automatically.</p>
            <p><strong>Actions:</strong> Audit ‚Üí Identify Issues ‚Üí Apply Fixes ‚Üí Verify Results</p>
        </div>

        <div>
            <button class="btn-primary" onclick="auditAllCustomers()">üîç Audit All Customers</button>
            <button class="btn-warning" onclick="identifyIssues()">‚ö†Ô∏è Identify Issues</button>
            <button class="btn-danger" onclick="fixAllIssues()">üîß Fix All Issues</button>
            <button class="btn-success" onclick="verifyFixes()">‚úÖ Verify Fixes</button>
            <button onclick="clearResults()">üóëÔ∏è Clear</button>
        </div>

        <div class="progress" id="progressContainer" style="display: none;">
            <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        </div>

        <div id="results"></div>
    </div>

    <script type="module">
        let db;
        let auditResults = [];
        let issuesFound = [];

        async function initializeDB() {
            try {
                const module = await import('./src/services/database.ts');
                db = new module.DatabaseService();
                await db.initialize();
                return true;
            } catch (error) {
                console.error('Database init failed:', error);
                return false;
            }
        }

        function addResult(message, type = 'info') {
            const results = document.getElementById('results');
            const alertClass = \`alert-\${type}\`;
            results.innerHTML += \`<div class="alert \${alertClass}">\${message}</div>\`;
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
            auditResults = [];
            issuesFound = [];
        }

        function showProgress(show, percent = 0) {
            const container = document.getElementById('progressContainer');
            const bar = document.getElementById('progressBar');
            container.style.display = show ? 'block' : 'none';
            bar.style.width = percent + '%';
        }

        window.auditAllCustomers = async function() {
            clearResults();
            addResult('üîç Starting Comprehensive Customer Balance Audit...', 'info');

            if (!await initializeDB()) {
                addResult('‚ùå Database initialization failed', 'danger');
                return;
            }

            try {
                showProgress(true, 10);
                
                // Get all customers
                const customers = await db.executeRawQuery(\`
                    SELECT id, name, balance, customer_type 
                    FROM customers 
                    WHERE id != -1 
                    ORDER BY id
                \`);

                addResult(\`üìä Found \${customers.length} customers to audit\`, 'info');
                showProgress(true, 20);

                // Audit each customer
                let auditTable = \`<table>
                    <tr>
                        <th>Customer</th>
                        <th>Stored Balance</th>
                        <th>Calculated Balance</th>
                        <th>Difference</th>
                        <th>Status</th>
                        <th>Issues</th>
                    </tr>\`;

                let totalIssues = 0;
                let customersProcessed = 0;

                for (const customer of customers) {
                    try {
                        // Calculate actual balance from ledger
                        const calculatedBalance = await calculateCustomerBalance(customer.id);
                        
                        // Get stored balance
                        const storedBalance = parseFloat(customer.balance || 0);
                        
                        // Calculate difference
                        const difference = Math.abs(storedBalance - calculatedBalance);
                        const hasIssue = difference > 0.01;
                        
                        if (hasIssue) totalIssues++;

                        const rowClass = hasIssue ? 'wrong' : 'fixed';
                        const status = hasIssue ? '‚ùå Mismatch' : '‚úÖ Correct';
                        const issues = hasIssue ? \`Rs. \${difference.toFixed(2)} difference\` : 'None';

                        auditTable += \`<tr class="\${rowClass}">
                            <td>\${customer.name} (ID: \${customer.id})</td>
                            <td>Rs. \${storedBalance.toFixed(2)}</td>
                            <td>Rs. \${calculatedBalance.toFixed(2)}</td>
                            <td>Rs. \${difference.toFixed(2)}</td>
                            <td>\${status}</td>
                            <td>\${issues}</td>
                        </tr>\`;

                        // Store audit result
                        auditResults.push({
                            customer: customer,
                            storedBalance: storedBalance,
                            calculatedBalance: calculatedBalance,
                            difference: difference,
                            hasIssue: hasIssue
                        });

                        customersProcessed++;
                        showProgress(true, 20 + (customersProcessed / customers.length) * 60);

                    } catch (error) {
                        addResult(\`‚ùå Error auditing \${customer.name}: \${error.message}\`, 'danger');
                    }
                }

                auditTable += '</table>';
                results.innerHTML += auditTable;

                // Summary
                addResult(\`
                    <div class="calculation-box">
                        <h3>üìä Audit Summary</h3>
                        <p><strong>Total Customers:</strong> \${customers.length}</p>
                        <p><strong>Customers with Issues:</strong> \${totalIssues}</p>
                        <p><strong>Customers Correct:</strong> \${customers.length - totalIssues}</p>
                        <p><strong>Success Rate:</strong> \${((customers.length - totalIssues) / customers.length * 100).toFixed(1)}%</p>
                    </div>
                \`, totalIssues > 0 ? 'warning' : 'success');

                showProgress(false);

            } catch (error) {
                addResult(\`‚ùå Audit failed: \${error.message}\`, 'danger');
                showProgress(false);
            }
        };

        async function calculateCustomerBalance(customerId) {
            // Calculate balance using the correct method
            const result = await db.executeRawQuery(\`
                SELECT 
                    COALESCE(SUM(CASE WHEN entry_type = 'debit' THEN amount ELSE 0 END), 0) as total_debits,
                    COALESCE(SUM(CASE WHEN entry_type = 'credit' THEN amount ELSE 0 END), 0) as total_credits,
                    COALESCE(SUM(CASE WHEN entry_type = 'debit' THEN amount ELSE -amount END), 0) as balance
                FROM customer_ledger_entries 
                WHERE customer_id = ? AND entry_type IN ('debit', 'credit')
            \`, [customerId]);

            return parseFloat(result[0]?.balance || 0);
        }

        window.identifyIssues = async function() {
            if (auditResults.length === 0) {
                addResult('‚ö†Ô∏è Run audit first to identify issues', 'warning');
                return;
            }

            clearResults();
            addResult('‚ö†Ô∏è Identifying Specific Balance Issues...', 'info');

            const customersWithIssues = auditResults.filter(r => r.hasIssue);
            
            if (customersWithIssues.length === 0) {
                addResult('‚úÖ No balance issues found!', 'success');
                return;
            }

            addResult(\`üîç Found \${customersWithIssues.length} customers with balance issues:\`, 'warning');

            for (const result of customersWithIssues) {
                addResult(\`
                    <div class="customer-row warning">
                        <h4>\${result.customer.name} (ID: \${result.customer.id})</h4>
                        <p><strong>Stored:</strong> Rs. \${result.storedBalance.toFixed(2)}</p>
                        <p><strong>Calculated:</strong> Rs. \${result.calculatedBalance.toFixed(2)}</p>
                        <p><strong>Difference:</strong> Rs. \${result.difference.toFixed(2)}</p>
                        <p><strong>Issue:</strong> \${result.storedBalance > result.calculatedBalance ? 'Stored balance too high' : 'Stored balance too low'}</p>
                    </div>
                \`, 'warning');

                // Check for specific issues
                await analyzeCustomerIssues(result.customer.id, result.customer.name);
            }
        };

        async function analyzeCustomerIssues(customerId, customerName) {
            try {
                // Check for problematic entries
                const problematicEntries = await db.executeRawQuery(\`
                    SELECT 
                        COUNT(CASE WHEN entry_type = 'adjustment' AND amount != 0 THEN 1 END) as adjustment_with_amount,
                        COUNT(CASE WHEN entry_type IN ('debit', 'credit') AND amount = 0 THEN 1 END) as zero_amount_entries,
                        COUNT(CASE WHEN description LIKE '%REFERENCE ONLY%' THEN 1 END) as reference_entries,
                        COUNT(CASE WHEN entry_type NOT IN ('debit', 'credit', 'adjustment') THEN 1 END) as unknown_entries
                    FROM customer_ledger_entries 
                    WHERE customer_id = ?
                \`, [customerId]);

                const issues = problematicEntries[0];
                let issueList = [];

                if (issues.adjustment_with_amount > 0) {
                    issueList.push(\`\${issues.adjustment_with_amount} adjustment entries with amounts\`);
                }
                if (issues.zero_amount_entries > 0) {
                    issueList.push(\`\${issues.zero_amount_entries} zero-amount debit/credit entries\`);
                }
                if (issues.reference_entries > 0) {
                    issueList.push(\`\${issues.reference_entries} reference-only entries\`);
                }
                if (issues.unknown_entries > 0) {
                    issueList.push(\`\${issues.unknown_entries} unknown entry types\`);
                }

                if (issueList.length > 0) {
                    addResult(\`   ‚Ä¢ Issues found: \${issueList.join(', ')}\`, 'warning');
                }

            } catch (error) {
                addResult(\`   ‚Ä¢ Error analyzing \${customerName}: \${error.message}\`, 'danger');
            }
        }

        window.fixAllIssues = async function() {
            if (auditResults.length === 0) {
                addResult('‚ö†Ô∏è Run audit first to identify issues to fix', 'warning');
                return;
            }

            clearResults();
            addResult('üîß Fixing All Customer Balance Issues...', 'info');

            const customersWithIssues = auditResults.filter(r => r.hasIssue);
            
            if (customersWithIssues.length === 0) {
                addResult('‚úÖ No issues to fix!', 'success');
                return;
            }

            showProgress(true, 0);
            let fixedCount = 0;
            let errorCount = 0;

            for (let i = 0; i < customersWithIssues.length; i++) {
                const result = customersWithIssues[i];
                
                try {
                    addResult(\`üîß Fixing \${result.customer.name}...\`, 'info');
                    
                    // Fix 1: Update stored balance to match calculated balance
                    await db.executeRawQuery(\`
                        UPDATE customers 
                        SET balance = ?, updated_at = CURRENT_TIMESTAMP 
                        WHERE id = ?
                    \`, [result.calculatedBalance, result.customer.id]);

                    // Fix 2: Clean up problematic entries
                    await cleanupCustomerEntries(result.customer.id);

                    addResult(\`‚úÖ Fixed \${result.customer.name} - Balance: Rs. \${result.calculatedBalance.toFixed(2)}\`, 'success');
                    fixedCount++;

                } catch (error) {
                    addResult(\`‚ùå Failed to fix \${result.customer.name}: \${error.message}\`, 'danger');
                    errorCount++;
                }

                showProgress(true, (i + 1) / customersWithIssues.length * 100);
            }

            addResult(\`
                <div class="calculation-box">
                    <h3>üîß Fix Summary</h3>
                    <p><strong>Customers Fixed:</strong> \${fixedCount}</p>
                    <p><strong>Errors:</strong> \${errorCount}</p>
                    <p><strong>Status:</strong> \${errorCount === 0 ? 'All issues resolved!' : 'Some issues remain'}</p>
                </div>
            \`, errorCount === 0 ? 'success' : 'warning');

            showProgress(false);
        };

        async function cleanupCustomerEntries(customerId) {
            // Remove adjustment entries that have non-zero amounts (they shouldn't)
            await db.executeRawQuery(\`
                DELETE FROM customer_ledger_entries 
                WHERE customer_id = ? 
                  AND entry_type = 'adjustment' 
                  AND amount != 0
            \`, [customerId]);

            // Update zero-amount debit/credit entries to have proper amounts if possible
            // (This would need more complex logic based on reference data)
        }

        window.verifyFixes = async function() {
            clearResults();
            addResult('‚úÖ Verifying All Fixes...', 'info');

            if (!await initializeDB()) {
                addResult('‚ùå Database initialization failed', 'danger');
                return;
            }

            // Re-run the audit to verify fixes
            await auditAllCustomers();
            
            const remainingIssues = auditResults.filter(r => r.hasIssue).length;
            
            if (remainingIssues === 0) {
                addResult('üéâ ALL BALANCE ISSUES RESOLVED! All customer balances are now correct.', 'success');
            } else {
                addResult(\`‚ö†Ô∏è \${remainingIssues} issues still remain. Manual intervention may be required.\`, 'warning');
            }
        };

        // Initialize on load
        initializeDB().then(() => {
            addResult('üöÄ Balance Audit Tool Ready. Click "Audit All Customers" to start.', 'info');
        });
    </script>
</body>

</html>